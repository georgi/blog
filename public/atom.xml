<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Matthias Georgi</title>
  <id>http://www.matthias-georgi.de</id>
  <updated>05 Jan 13 00:00</updated>
  <entry>
    <id>http://www.matthias-georgi.de/2013/1/how-to-write-a-blog-engine-in-haskell-part-1.html</id>
    <title type="text">How to write a blog engine in Haskell Part 1</title>
    <updated>01 Jan 13 00:00</updated>
    <content type="html">&lt;p&gt;I really like to evaluate programming languages based on their
practical value and one of the fun tasks is to write a small static
file blog engine. The engine just converts a bunch of markdown files
which are sorted into folders by month and year to html files given a
set of simple templates.&lt;/p&gt;

&lt;h2&gt;Top level structure&lt;/h2&gt;

&lt;p&gt;Basically the rendering of blog posts can be done in three steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Find all files that contain blog posts&lt;/li&gt;
&lt;li&gt;Read the markdown files into records&lt;/li&gt;
&lt;li&gt;Render each file to html and write to disk&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In Haskell these steps could be written as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;writeBlog :: IO ()
writeBlog = do
  files &amp;lt;- findFiles &amp;quot;posts&amp;quot;
  posts &amp;lt;- mapM readPost files
  mapM_ writePost posts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When working inside the IO monad, you will use &lt;code&gt;mapM&lt;/code&gt; and &lt;code&gt;mapM_&lt;/code&gt;
quite often, similar to &lt;code&gt;map&lt;/code&gt; they have following type signatures:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapM :: Monad m =&amp;gt; (a -&amp;gt; m b) -&amp;gt; [a] -&amp;gt; m [b]
mapM_ :: Monad m =&amp;gt; (a -&amp;gt; m b) -&amp;gt; [a] -&amp;gt; m ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They apply a monadic operation &lt;code&gt;a -&amp;gt; m b&lt;/code&gt; to each element of a list
and either you want to keep the result of each operation (mapM) or not
(mapM_).&lt;/p&gt;

&lt;p&gt;Interestingly there is a more generalized version in &lt;code&gt;Data.Traversable&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Monad m, Traversable t) =&amp;gt; (a -&amp;gt; m b) -&amp;gt; t a -&amp;gt; m (t b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function applies the monadic operation to anything that is
traversable. So you could build a tree data type and declare it as
instance of &lt;code&gt;Data.Traversable&lt;/code&gt; and use this function to apply the
operation while maintaining the tree structure. For example a tree
of files would be converted into a tree of blog posts.&lt;/p&gt;

&lt;h2&gt;Find files&lt;/h2&gt;

&lt;p&gt;So the first step in the blog rendering process would be to find all
files containing a post. So I created a folder named &lt;code&gt;posts&lt;/code&gt; which
contains folders for each year, which in turn contain folders for each
month, which finally contain all the blog posts.&lt;/p&gt;

&lt;p&gt;What we want now is the same as the UNIX command &lt;code&gt;find posts -type f&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This can be done by looking at the entries of a folder and entering
each sub folder to examine its contents. When we find a file, we
collect it into a result list, which will contain all files
eventually.&lt;/p&gt;

&lt;p&gt;When dealing with tree structures like a file system, recursion is an
elegant alternative to iteration. For each folder we find, the function
should call itself recursively until it ends up at the bottom most
level containing the files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;findFiles :: FilePath -&amp;gt; IO [FilePath]
findFiles path = do
  isFile &amp;lt;- doesFileExist path
  if isFile then
      return [path]
    else do
      entries &amp;lt;- getEntries path
      paths &amp;lt;- return $ map (\ entry -&amp;gt; path ++ &amp;quot;/&amp;quot; ++ entry) entries
      files &amp;lt;- mapM findFiles paths
      return $ concat files
  where
    getEntries filepath = do
      contents &amp;lt;- getDirectoryContents filepath
      return $ filter ((/= &amp;#39;.&amp;#39;) . head) contents
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;findFiles&lt;/code&gt; takes a &lt;code&gt;FilePath&lt;/code&gt; and returns all files found in this
folder or its subfolders. When you pass a file it will just return a
list with this one file.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getEntries&lt;/code&gt; is a small helper function which returns all entries of
a folder without &amp;#39;.&amp;#39; and &amp;#39;..&amp;#39;.&lt;/p&gt;

&lt;p&gt;The else branch works like this: it reads all entries of the folder,
prepends the current path, recurses for each entry, collects the
return values and flattens them into one big list.&lt;/p&gt;

&lt;h2&gt;Reading posts into records&lt;/h2&gt;

&lt;p&gt;The data type representing a post is super simple. It just contains
the &lt;code&gt;folder&lt;/code&gt; (e.g. &amp;ldquo;posts/2012/12&amp;rdquo;), the &lt;code&gt;file&lt;/code&gt; (e.g. &lt;code&gt;post-title.md&lt;/code&gt;)
and the &lt;code&gt;text&lt;/code&gt; of the post.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data Post = Post { folder, file, text :: String };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;readPost&lt;/code&gt; therefore takes a &lt;code&gt;FilePath&lt;/code&gt; and reads the file contents,
decomposing the path name into &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;, which we
feed into the record constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;readPost :: FilePath -&amp;gt; IO Post
readPost path = do
  s &amp;lt;- readFile path
  let [_, year, month, filename] = splitOn &amp;quot;/&amp;quot; path in
    return Post { folder = year ++ &amp;quot;/&amp;quot; ++ month, file = filename, text = s }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;splitOn&lt;/code&gt; is taken from the &lt;code&gt;Data.List.Split&lt;/code&gt; module in the &lt;code&gt;split&lt;/code&gt; package
and splits a string into a list of strings given a delimiter string.&lt;/p&gt;

&lt;h2&gt;To be continued&lt;/h2&gt;

&lt;p&gt;Next part in this series will take a look at the actual rendering of blog
post using the &lt;code&gt;sundown&lt;/code&gt; package.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2013/1/how-to-write-a-blog-engine-in-haskell-part-1.html" type="text/html" />
    <published>01 Jan 13 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2011/6/vtouch-control-ableton-live-in-a-webbrowser.html</id>
    <title type="text">vTouch - Control Ableton Live in a Webbrowser</title>
    <updated>01 Jun 11 00:00</updated>
    <content type="html">&lt;p&gt;VTouch is a multitouch browser frontend for Ableton Live. Inside your
webbrowser you can control clip triggering, volume, send and return
levels, mute, solo, record states. This works also on the network, so
you can connect your mobile phone, iPads or android tablets easily by
just browsing to you local webserver.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.matthias-georgi.de/images/vtouch.gif&quot; alt=&quot;vTouch&quot;&gt;&lt;/p&gt;

&lt;h3&gt;Screencast&lt;/h3&gt;

&lt;iframe width=&quot;425&quot; height=&quot;349&quot; src=&quot;http://www.youtube.com/embed/qFmiIcgRIao&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h3&gt;About the Hack&lt;/h3&gt;

&lt;p&gt;Ableton Live is an digital audio workstation, which is well suited for
live performances. Lots of parameters can be manipulated, midi or
audio loops can be triggered. Unfortunately it is cumbersome to use
this software with a touch device. A user interface specifically
designed to be used on multitouch devices, which is also portable
across platforms, offers many benefits and possibilities. Imagine a
whole band jamming on iPads with ohne live setup over a wireless
network.&lt;/p&gt;

&lt;h3&gt;Technology used&lt;/h3&gt;

&lt;p&gt;The frontend is rendered on HTML5 Canvas and communicates with a
nodejs server via websockets. On the backend the webserver talks to a
running ableton live instance and sends updates to all connected
clients.&lt;/p&gt;

&lt;p&gt;The canvas frontend is supported on all modern browsers including
apple mobile safari and android browsers. We created a small widget
library named canvas.ui to take care of multitouch events, rendering
and layout management.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2011/6/vtouch-control-ableton-live-in-a-webbrowser.html" type="text/html" />
    <published>01 Jun 11 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2011/6/quick-guide-for-passenger-on-natty-narwhal.html</id>
    <title type="text">Quick Guide for Passenger on Natty Narwhal</title>
    <updated>01 Jun 11 00:00</updated>
    <content type="html">&lt;p&gt;This is a short guide for installing &lt;a href=&quot;http://www.modrails.com/&quot;&gt;Phusion Passenger&lt;/a&gt; and &lt;a href=&quot;http://www.rubyenterpriseedition.com/&quot;&gt;Ruby
Enterprise Editition&lt;/a&gt; on Ubuntu Natty Narwhal. Depending on your machine
this will take 30-60 minutes on a fresh Ubuntu install.&lt;/p&gt;

&lt;h3&gt;Installing build tools and libraries&lt;/h3&gt;

&lt;p&gt;First we need to install the compiler toolchain (make, gcc and libc)
and necessary libraries.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install build-essential zlib1g-dev libssl-dev libreadline5-dev libmysqlclient-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Ruby Enterprise Edition&lt;/h3&gt;

&lt;p&gt;We are going to download and compile Ruby Enterprise Edition. The
installer asks for the target directory.  I would recommend to install
into /opt/ruby unless you want to host different versions on this machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://rubyenterpriseedition.googlecode.com/files/ruby-enterprise-1.8.7-2011.03.tar.gz
$ tar xzf ruby-enterprise-1.8.7-2011.03.tar.gz
$ cd ruby-enterprise-1.8.7-2011.03
$ ./installer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we include the path to the ruby binaries in /etc/environment. It should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PATH=&amp;quot;/opt/ruby/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After relogin you should be able to type ruby -v and get a response like this:    &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruby 1.8.7 (2011-02-18 patchlevel 334) [x86_64-linux], MBARI 0x6770, Ruby Enterprise Edition 2011.03
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Apache and Passenger&lt;/h3&gt;

&lt;p&gt;We need to install Apache and necessary development libraries to compile Phusion Passenger. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install libcurl4-openssl-dev apache2-mpm-prefork apache2-prefork-dev libapr1-dev libaprutil1-dev
$ passenger-install-apache2-module
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Apache configuration&lt;/h3&gt;

&lt;p&gt;The compilation of the Passenger Apache
module finished with an instruction for your httpd.conf. Depending on
you passenger version, you will get something like this, which you add
to your &lt;code&gt;/etc/apache2/httpd.conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoadModule passenger_module /opt/ruby/lib/ruby/gems/1.8/gems/passenger-3.0.7/ext/apache2/mod_passenger.so
PassengerRoot /opt/ruby/lib/ruby/gems/1.8/gems/passenger-3.0.7
PassengerRuby /opt/ruby/bin/ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you browse to your url, you should see the standard apache &amp;ldquo;It works&amp;rdquo; page.&lt;/p&gt;

&lt;h3&gt;MySQL&lt;/h3&gt;

&lt;p&gt;The Ruby Enterprise Installer already compiled Ruby&amp;#39;s mysql client
library, now we need the server and client.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install mysql-server mysql-client
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Virtual host config&lt;/h3&gt;

&lt;p&gt;Adding a virtual host for your rails application is easy. Assuming
that your application resides in /var/www/myapp create a file named
&lt;code&gt;/etc/apache2/sites-available/myapp&lt;/code&gt; and fill in :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
    ServerName myserver.com
    DocumentRoot /var/www/myapp/public
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we disable the default site and add our new virtual host:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ a2dissite default
$ a2ensite myapp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After restarting Apache your Rails application should run on Apache:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /etc/init.d/apache2 restart
&lt;/code&gt;&lt;/pre&gt;
</content>
    <link href="http://www.matthias-georgi.de/2011/6/quick-guide-for-passenger-on-natty-narwhal.html" type="text/html" />
    <published>01 Jun 11 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2011/6/emacs-dark-theme.html</id>
    <title type="text">Emacs Dark Theme</title>
    <updated>01 Jun 11 00:00</updated>
    <content type="html">&lt;p&gt;Recently I updated my Emacs setup and decided to go for a more minimal
color theme. Especially on long coding nights you want a theme without
distracting colors.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.matthias-georgi.de/images/emacs-dark-theme.png&quot; alt=&quot;Emacs dark theme&quot;&gt;&lt;/p&gt;

&lt;h3&gt;Configuration&lt;/h3&gt;

&lt;p&gt;Just paste this code into your emacs condiguration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (set-face-attribute &amp;#39;default nil
                     :background &amp;quot;grey20&amp;quot;
                     :foreground &amp;quot;grey90&amp;quot;)

 (set-face-attribute &amp;#39;modeline nil
                     :background &amp;quot;grey10&amp;quot;
                     :foreground &amp;quot;grey90&amp;quot;)

 (set-face-attribute &amp;#39;cursor nil
                     :background &amp;quot;white&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-builtin-face nil
                     :foreground &amp;quot;grey60&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-comment-face nil
                     :foreground &amp;quot;grey60&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-constant-face nil
                     :foreground &amp;quot;grey60&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-keyword-face nil
                     :foreground &amp;quot;white&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-string-face nil
                     :foreground &amp;quot;white&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-variable-name-face nil
                     :foreground &amp;quot;lightblue&amp;quot;)

 (set-face-attribute &amp;#39;font-lock-function-name-face nil
                     :foreground &amp;quot;lightblue&amp;quot;)

 (set-face-attribute &amp;#39;region nil
                     :background &amp;quot;#111&amp;quot;)                    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Additional faces&lt;/h3&gt;

&lt;p&gt;If you use speedbar or elscreen, you can set additional faces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(set-face-attribute &amp;#39;speedbar-file-face nil
                    :foreground &amp;quot;white&amp;quot;)

(set-face-attribute &amp;#39;elscreen-tab-background-face nil
                    :background &amp;quot;grey10&amp;quot;
                    :foreground &amp;quot;grey90&amp;quot;)

(set-face-attribute &amp;#39;elscreen-tab-control-face nil
                    :background &amp;quot;grey20&amp;quot;
                    :foreground &amp;quot;grey90&amp;quot;)

(set-face-attribute &amp;#39;elscreen-tab-current-screen-face nil
                    :background &amp;quot;grey20&amp;quot;
                    :foreground &amp;quot;grey90&amp;quot;)

(set-face-attribute &amp;#39;elscreen-tab-other-screen-face nil
                    :background &amp;quot;grey30&amp;quot;
                    :foreground &amp;quot;grey60&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</content>
    <link href="http://www.matthias-georgi.de/2011/6/emacs-dark-theme.html" type="text/html" />
    <published>01 Jun 11 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2009/4/rackdav-web-authoring-for-rack.html</id>
    <title type="text">RackDAV - Web Authoring for Rack</title>
    <updated>01 Apr 09 00:00</updated>
    <content type="html">&lt;p&gt;RackDAV is Handler for &lt;a href=&quot;http://github.com/chneukirchen/rack&quot;&gt;Rack&lt;/a&gt;, which allows content authoring over
HTTP. RackDAV brings its own file backend, but other backends are
possible by subclassing RackDAV::Resource.&lt;/p&gt;

&lt;h2&gt;Install&lt;/h2&gt;

&lt;p&gt;Just install the gem from github:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem sources -a http://gems.github.com
$ sudo gem install georgi-rack_dav
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Quickstart&lt;/h2&gt;

&lt;p&gt;If you just want to share a folder over WebDAV, you can just start a
simple server with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rack_dav
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will start a WEBrick server on port 3000, which you can connect
to without authentication.&lt;/p&gt;

&lt;h2&gt;Rack Handler&lt;/h2&gt;

&lt;p&gt;Using RackDAV inside a rack application is quite easy. A simple rackup
script looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;rubygems&amp;#39;
require &amp;#39;rack_dav&amp;#39;

use Rack::CommonLogger

run RackDAV::Handler.new(&amp;#39;/path/to/docs&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Implementing your own WebDAV resource&lt;/h2&gt;

&lt;p&gt;RackDAV::Resource is an abstract base class and defines an interface
for accessing resources.&lt;/p&gt;

&lt;p&gt;Each resource will be initialized with a path, which should be used to
find the real resource.&lt;/p&gt;

&lt;p&gt;RackDAV::Handler needs to be initialized with the actual resource class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RackDAV::Handler.new(:resource_class =&amp;gt; MyResource)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RackDAV needs some information about the resources, so you have to
implement following methods:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;children&lt;/strong&gt;: If this is a collection, return the child resources.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;collection?&lt;/strong&gt;: Is this resource a collection?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;exist?&lt;/strong&gt;: Does this recource exist?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;creation_date&lt;/strong&gt;: Return the creation time.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;last_modified&lt;/strong&gt;: Return the time of last modification.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;last_modified=(time)&lt;/strong&gt;: Set the time of last modification.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;etag&lt;/strong&gt;: Return an Etag, an unique hash value for this resource.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;content_type&lt;/strong&gt;: Return the mime type of this resource.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;content_length&lt;/strong&gt;: Return the size in bytes for this resource.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most importantly you have to implement the actions, which are called
to retrieve and change the resources:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;get(request, response)&lt;/strong&gt;: Write the content of the resource to the response.body.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;put(request, response)&lt;/strong&gt;: Save the content of the request.body.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;post(request, response)&lt;/strong&gt;: Usually forbidden.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;delete&lt;/strong&gt;: Delete this resource.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;copy(dest)&lt;/strong&gt;: Copy this resource to given destination resource.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;move(dest)&lt;/strong&gt;: Move this resource to given destination resource.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;make_collection&lt;/strong&gt;: Create this resource as collection.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note, that it is generally possible, that a resource object is
instantiated for a not yet existing resource.&lt;/p&gt;

&lt;p&gt;For inspiration you should have a look at the FileResource
implementation. Please let me now, if you are going to implement a new
type of resource.&lt;/p&gt;

&lt;h3&gt;RackDAV on GitHub&lt;/h3&gt;

&lt;p&gt;Download or fork the project on its &lt;a href=&quot;http://github.com/georgi/rack_dav&quot;&gt;Github page&lt;/a&gt;&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2009/4/rackdav-web-authoring-for-rack.html" type="text/html" />
    <published>01 Apr 09 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2008/9/using-javascript-templates-for-a-delicious-sidebar.html</id>
    <title type="text">Using Javascript Templates for a Delicious Sidebar</title>
    <updated>01 Sep 08 00:00</updated>
    <content type="html">&lt;p&gt;Processing JSON data from an external source with Javascript templates
is a natural fit. Create a template inside your &lt;em&gt;HTML Document&lt;/em&gt; by
adding class names and variables and write a few lines for fetching
the &lt;em&gt;JSON&lt;/em&gt;, that&amp;#39;s all. This tutorial is an example for my Javascript
Template Engine called &lt;strong&gt;&lt;a href=&quot;http://www.matthias-georgi.de/2008/9/patroon-a-javascript-template-engine-part-2.html&quot;&gt;Patroon&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h3&gt;Writing the template&lt;/h3&gt;

&lt;p&gt;In my sidebar you can see the result of my example. My latest
bookmarks are shown as a list. Quite simple. The template looks like
this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;bookmarks&amp;quot;&amp;gt;
  &amp;lt;ul id=&amp;quot;bookmarks-template&amp;quot;&amp;gt;
    &amp;lt;li class=&amp;quot;bookmark&amp;quot;&amp;gt;
      &amp;lt;a href=&amp;quot;{u}&amp;quot;&amp;gt;{d}&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There a two variables here &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;. I don&amp;#39;t know if &lt;em&gt;Delicious&lt;/em&gt;
wants to save some bytes here, but descriptive names wouldn&amp;#39;t hurt in
this case. &lt;code&gt;u&lt;/code&gt; is refering to the url of the bookmark and &lt;code&gt;d&lt;/code&gt; is the
title. We are expanding an array of bookmarks into the &lt;code&gt;li&lt;/code&gt; element,
which is marked by the class name &lt;code&gt;bookmark&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Fetching the JSON Feed&lt;/h3&gt;

&lt;p&gt;The Feed resides on a different domain, so we have to use a &lt;code&gt;script&lt;/code&gt;
tag to fetch the data. This is because of security restrictions, which
limits &lt;em&gt;AJAX&lt;/em&gt; calls to the same domain of the current web page.&lt;/p&gt;

&lt;p&gt;The feed url for your bookmarks looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://feeds.delicious.com/v2/json/{username}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to fetch some of the other feeds, just look at the
&lt;a href=&quot;http://delicious.com/help/json/&quot;&gt;documentation&lt;/a&gt;, which describes 18 different feed types.&lt;/p&gt;

&lt;p&gt;A very useful option in our case is to provide a callback function,
which gets called after the &lt;em&gt;JSON&lt;/em&gt; script was loaded. We define
&lt;code&gt;renderBookmarks&lt;/code&gt; as our callback.&lt;/p&gt;

&lt;p&gt;The following code inserts the script tag to load the &lt;em&gt;Delicious&lt;/em&gt;
&lt;em&gt;JSON&lt;/em&gt; feed of my bookmarks. This is done when the page is loaded:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(function() {
    var head = document.getElementsByTagName(&amp;quot;head&amp;quot;)[0];
    var script = document.createElement(&amp;#39;script&amp;#39;);

    script.setAttribute(&amp;quot;src&amp;quot;, &amp;quot;http://feeds.delicious.com/v2/json/matthias_georgi?callback=renderBookmarks&amp;quot;);
    script.setAttribute(&amp;quot;type&amp;quot;, &amp;quot;text/javascript&amp;quot;);

    head.appendChild(script);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;#39;m using jQuery here for the window load event. Other libraries would
need some other api call.&lt;/p&gt;

&lt;h3&gt;Rendering the JSON data&lt;/h3&gt;

&lt;p&gt;The code for rendering consists of just two lines. First we are
instantiating the Template. We have to provide the id of the template
node (the template is part of your document).&lt;/p&gt;

&lt;p&gt;Second we expand the template using the jQuery helper. The variable
&lt;code&gt;data&lt;/code&gt; contains just the array of bookmarks. To match the &lt;code&gt;li&lt;/code&gt; element
of the template, which has the class name &lt;code&gt;bookmark&lt;/code&gt;, we must set the
template variable &lt;code&gt;bookmark&lt;/code&gt; to hold the bookmarks array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function renderBookmarks(data) {
  var template = new Template(&amp;#39;bookmarks-template&amp;#39;);
  $(&amp;#39;.bookmarks&amp;#39;).expand(template, { bookmark: data });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Result&lt;/h3&gt;

&lt;p&gt;The resulting &lt;em&gt;HTML&lt;/em&gt; of my bookmark sidebar looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;bookmarks&amp;quot;&amp;gt;
  &amp;lt;ul id=&amp;quot;bookmarks-template&amp;quot;&amp;gt;            
    &amp;lt;li class=&amp;quot;bookmark&amp;quot;&amp;gt;
      &amp;lt;a href=&amp;quot;http://delicious.com/help/json/&amp;quot;&amp;gt;
        &amp;lt;span&amp;gt;delicious/help/feeds&amp;lt;/span&amp;gt;
      &amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li class=&amp;quot;bookmark&amp;quot;&amp;gt;
      &amp;lt;a href=&amp;quot;http://code.google.com/apis/youtube/reference.html&amp;quot;&amp;gt;
        &amp;lt;span&amp;gt;Reference Guide: Data API Protocol - YouTube APIs and Tools - Google Code&amp;lt;/span&amp;gt;
      &amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li class=&amp;quot;bookmark&amp;quot;&amp;gt;
      &amp;lt;a href=&amp;quot;http://rewrite.rubyforge.org/&amp;quot;&amp;gt;
      &amp;lt;span&amp;gt;rewrite&amp;lt;/span&amp;gt;
      &amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li class=&amp;quot;bookmark&amp;quot;&amp;gt;
      &amp;lt;a href=&amp;quot;http://www.infoq.com/interviews/Rewrite-Reginald-Braithwaite&amp;quot;&amp;gt;
        &amp;lt;span&amp;gt;InfoQ: Reginald Braithwaite on Rewrite&amp;lt;/span&amp;gt;
      &amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may wonder, why there are extra span elements around the variable
expansions. Well this is necessary for inserting &lt;em&gt;HTML&lt;/em&gt; from a
variable. If I want to replace a text node with some &lt;em&gt;HTML&lt;/em&gt;, I have to
insert a &lt;em&gt;span&lt;/em&gt; element and use the &lt;code&gt;innerHTML&lt;/code&gt; property. If you know
something better, please let me know.&lt;/p&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Using &lt;em&gt;Javascript&lt;/em&gt; templates with &lt;em&gt;JSON&lt;/em&gt; feeds is simple and
efficient. You write standards-compliant &lt;em&gt;HTML&lt;/em&gt; sprinkled with some
variables and expand this with some &lt;em&gt;JSON&lt;/em&gt; data, that&amp;#39;s all.&lt;/p&gt;

&lt;h3&gt;Related Work&lt;/h3&gt;

&lt;p&gt;There are some other libraries for javascript templating, which are
related to &lt;strong&gt;Patroon&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://beebole.com/pure/&quot;&gt;PURE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jsrepeater.devprog.com/&quot;&gt;jsRepeater&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://code.google.com/p/trimpath/wiki/JavaScriptTemplates&quot;&gt;TrimPath&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://embeddedjs.com/&quot;&gt;EmbeddedJS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Patroon is probably the smallest templating solution around and
consists only of 130 lines of code.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2008/9/using-javascript-templates-for-a-delicious-sidebar.html" type="text/html" />
    <published>01 Sep 08 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2008/9/shinmun-a-small-and-beautiful-blog-engine.html</id>
    <title type="text">Shinmun, a small and beautiful blog engine</title>
    <updated>01 Sep 08 00:00</updated>
    <content type="html">&lt;p&gt;Shinmun is a minimalist blog engine. You just write posts as text files,
render them to static files and push your blog to your server.&lt;/p&gt;

&lt;p&gt;This allows you to write posts in your favorite editor like Emacs or
VI and use a VCS like git.&lt;/p&gt;

&lt;p&gt;Your layout can be customized by a set of &lt;em&gt;ERB templates&lt;/em&gt;. These
templates have access to &lt;code&gt;Post&lt;/code&gt; objects and &lt;em&gt;helper methods&lt;/em&gt; so that
anybody who knows &lt;em&gt;Rails&lt;/em&gt; should feel comfortable with it.&lt;/p&gt;

&lt;h3&gt;Shinmun Features&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Index listing&lt;/li&gt;
&lt;li&gt;Category listing&lt;/li&gt;
&lt;li&gt;Archive listings for each month&lt;/li&gt;
&lt;li&gt;RSS feeds for index and category pages&lt;/li&gt;
&lt;li&gt;Builtin webserver for realtime rendering&lt;/li&gt;
&lt;li&gt;Compression of javascript files with PackR&lt;/li&gt;
&lt;li&gt;Included syntax highlighting through &lt;code&gt;highlight.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;AJAX comment system with PHP JSON file storage&lt;/li&gt;
&lt;li&gt;Integration of WMD-Markdown Editor for commenting&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Quickstart&lt;/h3&gt;

&lt;p&gt;Install the gem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install shinmun
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Download and extract the example blog from my &lt;a href=&quot;http://github.com/georgi/shinmun-example/tree/master&quot;&gt;github repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Issue the following commands and you will see the blog on
&lt;code&gt;http://localhost:3000&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd shinmun-example
shinmun server
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Writing Posts&lt;/h3&gt;

&lt;p&gt;Posts can be created by using the &lt;code&gt;shinmun&lt;/code&gt; command inside your blog folder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shinmun new &amp;#39;The title of the post&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Shinmun will then create a post file in the right place, for example
in &lt;code&gt;posts/2008/9/the-title-of-the-post.md&lt;/code&gt;. After creating you will
probably open the file, set the category and start writing your new
article.&lt;/p&gt;

&lt;p&gt;Now you want to look at your rendered post. Just run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shinmun server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go to &lt;code&gt;http://localhost:3000&lt;/code&gt; and you will see your blog served in
realtime. Just change and save any of your posts and you will see the
new output in your browser.&lt;/p&gt;

&lt;p&gt;After finishing your post, you may run &lt;code&gt;shinmun render&lt;/code&gt; and the output
will be rendered to the &lt;em&gt;public&lt;/em&gt; folder.&lt;/p&gt;

&lt;p&gt;By issuing the &lt;code&gt;shinmun push&lt;/code&gt; command your blog will be pushed to your
server using rsync. This works only, if you define the blog_repository
variable inside blog.yml. It should contain something like
&lt;code&gt;user@myhost.com:/var/www/my-site/&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Post Format&lt;/h3&gt;

&lt;p&gt;Each blog post is just a text file with an optional header section and
a markup body, which are separated by a newline. Normally you don&amp;#39;t
have to worry about the post format, if you create posts with the
&lt;code&gt;shinmun new&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;first line&lt;/strong&gt; of the header should start with 3 dashes as usual
for a YAML document.&lt;/p&gt;

&lt;p&gt;The title of your post will be parsed from your first heading
according to the document type. Shinmun will try to figure out the
title for Markdown, Textile and HTML files.&lt;/p&gt;

&lt;p&gt;The yaml header may have following attributes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;date&lt;/code&gt;: post will show up in blog page and archive pages&lt;/li&gt;
&lt;li&gt;&lt;code&gt;category&lt;/code&gt;: post will show up in the defined category page&lt;/li&gt;
&lt;li&gt;&lt;code&gt;guid&lt;/code&gt;: will be set automatically by Shinmun&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Posts without a date are by definition static pages.&lt;/p&gt;

&lt;p&gt;Example post:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--- 
category: Ruby
date: 2008-09-05
guid: 7ad04f10-5dd6-012b-b53c-001a92975b89

BlueCloth, a Markdown library
=============================

This is the summary, which is by definition the first paragraph of the
article. The summary shows up in category listings or the index listing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The guid should never change, as it will be you used for identifying
posts for comments.&lt;/p&gt;

&lt;h3&gt;Directory layout&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Your &lt;strong&gt;assets&lt;/strong&gt; are in the &lt;code&gt;assets&lt;/code&gt; folder, which gets copied to the
public folder in the render step.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;strong&gt;settings of your blog&lt;/strong&gt; are defined in &lt;code&gt;config/blog.yml&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Your &lt;strong&gt;posts&lt;/strong&gt; reside in the &lt;code&gt;posts&lt;/code&gt; folder sorted by year/month.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Your &lt;strong&gt;pages&lt;/strong&gt; are located in the &lt;code&gt;pages&lt;/code&gt; folder.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Template&lt;/strong&gt; files are in the &lt;code&gt;templates&lt;/code&gt; folder.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;strong&gt;index page&lt;/strong&gt; of your blog is defined in &lt;code&gt;pages/index.rhtml&lt;/code&gt; and
may be customized.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Archive pages&lt;/strong&gt; will be rendered to files like &lt;code&gt;public/2008/9/index.html&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Category pages&lt;/strong&gt; will be rendered to files like &lt;code&gt;public/categories/ruby.html&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An example tree:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ assets
  + images
  + stylesheets
  + javascripts      
+ config
  + blog.yml
+ pages
  + about.md
  + index.rhtml
+ posts
  + 2007
  + 2008
    + 9
      + my-article.md
+ templates
  + feed.rxml
  + layout.rhtml
  + page.rhtml  
  + post.rhtml  
  + posts.rhtml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ public
  + index.html
  + about.html
  + categories
    + emacs.html
    + ruby.html
  + 2007   
  + 2008
    + 9
      + my-article.html
  + images
  + stylesheets
  + javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Config file&lt;/h3&gt;

&lt;p&gt;The configuration of the blog system consists of some variables
encoded as yaml file:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;blog_title: the title of your blog, used for rss&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;blog_description: used for rss&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;blog_language: used for rss&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;blog_author: used for rss, acts also as fallback for the blog.author variable&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;blog_url: used for rss&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;blog_repository: path for rsync, used for &lt;code&gt;shinmun push&lt;/code&gt; command&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;base_path: if your blog should not be rendered to your site
root, you can define a sub path here (like &lt;code&gt;blog&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;images_path: used for templates helper, defaults to &lt;code&gt;images&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;javascripts_path: used for templates helper, defaults to &lt;code&gt;javascripts&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;stylesheets_path: used for templates helper, defaults to &lt;code&gt;stylesheets&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pack_javascripts: a list of scripts to be compressed&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pack_stylesheets: a list of stylesheets to be concatenated&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Layout&lt;/h3&gt;

&lt;p&gt;Layout and templates are rendered by &lt;em&gt;ERB&lt;/em&gt;.  The layout is defined in
&lt;code&gt;layout.rhtml&lt;/code&gt;. The content will be provided in the variable
&lt;code&gt;@content&lt;/code&gt;. A minimal example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;%= @blog_title %&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;%= stylesheet_link_tag &amp;#39;style&amp;#39; %&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
     &amp;lt;%= @content %&amp;gt;
  &amp;lt;/body&amp;gt;
 &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Helpers&lt;/h3&gt;

&lt;p&gt;There are also helper methods, which work the same way like the &lt;em&gt;Rails&lt;/em&gt;
helpers. The most important ones are these:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;stylesheet_link_tag(*names)&lt;/code&gt; links a stylesheet with a timestamp&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;javascript_tag(*names)&lt;/code&gt; includes a javascript with a timestamp&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;image_tag(src, options = {})&lt;/code&gt; renders an image tag&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;link_to(text, path, options = {})&lt;/code&gt; renders a link&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Stylesheets, javascripts and images should be included by using theses
helpers. The helper methods will include a timestamp of the
modification time as &lt;code&gt;querystring&lt;/code&gt;, so that the browser will fetch the
new resource if it has been changed.&lt;/p&gt;

&lt;p&gt;If you want to define your own helpers, just define a file named
&lt;code&gt;templates/helpers.rb&lt;/code&gt; with a module named &lt;code&gt;Shinmun::Helpers&lt;/code&gt;. This
module will be included into the &lt;code&gt;Shinmun::Template&lt;/code&gt; class.&lt;/p&gt;

&lt;h3&gt;Post Template&lt;/h3&gt;

&lt;p&gt;The attributes of a post are accessible as instance variables in a template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;article&amp;quot;&amp;gt;    

  &amp;lt;div class=&amp;quot;date&amp;quot;&amp;gt;
    &amp;lt;%= date @date %&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;h2&amp;gt;&amp;lt;%= @title %&amp;gt;&amp;lt;/h2&amp;gt;  

  &amp;lt;%= @body %&amp;gt;

  &amp;lt;h3&amp;gt;Comments&amp;lt;/h3&amp;gt;

  &amp;lt;!-- Here you may put my commenting system --&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;RSS Feeds&lt;/h3&gt;

&lt;p&gt;Feeds will be rendered by the &lt;em&gt;ERB template&lt;/em&gt;
&lt;code&gt;templates/feed.rxml&lt;/code&gt;. Some of the variables have been read from the
&lt;code&gt;blog.yml&lt;/code&gt;, like &lt;code&gt;@blog_title&lt;/code&gt;, other variables have been determined
by the engine like &lt;code&gt;@posts&lt;/code&gt; or &lt;code&gt;@category&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Packr Support&lt;/h3&gt;

&lt;p&gt;If you set the variables &lt;code&gt;pack_javascripts&lt;/code&gt; or &lt;code&gt;pack_stylesheets&lt;/code&gt;,
Shinmun will create the files &lt;code&gt;all.js&lt;/code&gt; or &lt;code&gt;all.css&lt;/code&gt; automatically
on rendering (even on each request of the webserver).&lt;/p&gt;

&lt;p&gt;The Javascript will be compressed with Packr and for performance
reasons, minified versions for each of your javascripts will be
created automatically in &lt;code&gt;assets/javascripts&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The stylesheets will be just concatenated to one file named &lt;code&gt;all.css&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that you define a yaml array of filenames without file
extensions, so it should like &lt;code&gt;[jquery, jquery-form]&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Commenting System&lt;/h3&gt;

&lt;p&gt;As I am not willing to build up a whole Rails stack for a single blog,
I was looking for a simple storage for comments. I really like the
JSON format. It works seamlessly with Javascript libraries and can be
serialized and deserialized from almost any language.&lt;/p&gt;

&lt;p&gt;Read about my &lt;a href=&quot;http://www.matthias-georgi.de/commenting-system-with-lightweight-json-store.html&quot;&gt;lightweight commenting system&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Download&lt;/h3&gt;

&lt;p&gt;Simply install the gem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install shinmun
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Download or fork the package at my &lt;a href=&quot;http://github.com/georgi/shinmun/tree/master&quot;&gt;github repository&lt;/a&gt;&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2008/9/shinmun-a-small-and-beautiful-blog-engine.html" type="text/html" />
    <published>01 Sep 08 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2008/9/relax-ng-schema-for-adobe-flex-3.html</id>
    <title type="text">Relax NG Schema for Adobe Flex 3</title>
    <updated>01 Sep 08 00:00</updated>
    <content type="html">&lt;p&gt;In the past Flex development on Emacs was not as it should be because
of a missing Relax NG Schema, which is needed for nxml-mode to work
properly. To improve the situation I developed a MXML Schema generator
based on the &lt;a href=&quot;http://code.google.com/p/xsd4mxml/&quot;&gt;XSD generator&lt;/a&gt; of &lt;a href=&quot;http://flexiglas.blogspot.com/&quot;&gt;Ali Mansuroglu&lt;/a&gt;. Now Emacs
knows your Schema and can help you typing and validating MXML files.&lt;/p&gt;

&lt;h3&gt;Emacs NXML completion&lt;/h3&gt;

&lt;p&gt;Editing MXML files is now a breeze with the superb completion features
of nxml-mode on Emacs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;completion of tag names&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;completion of attribute keys&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;completion of attribute values (e.g. enumerations)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;How does it work?&lt;/h3&gt;

&lt;p&gt;The schema generator reads a manifest file with all classes to be
exported.  Now for each class the generator asks the runtime to
provide the needed information about attributes, events and
styles (the flash runtime has a nice function called &lt;code&gt;describeType&lt;/code&gt;,
which returns a XML representation of a type).&lt;/p&gt;

&lt;p&gt;The tricky part is to convince the &lt;em&gt;MXML&lt;/em&gt; compiler to include all
classes and metadata into the &lt;em&gt;SWF&lt;/em&gt; file. Thanks to Ali, I needn&amp;#39;t to
figure this out, as he provides an Ant file which already has the
needed compiler flags.&lt;/p&gt;

&lt;h3&gt;How does the schema look like?&lt;/h3&gt;

&lt;p&gt;The schema just lists all class names as elements and lists their
properties, events and styles as attributes. Furthermore as much type
information is preserved as possible using xsd types. So for example
the &lt;code&gt;dropdownWith&lt;/code&gt; of a &lt;code&gt;ComboBox&lt;/code&gt; must be a float. XML Editors like
nxml-mode in Emacs can validate this as yout type.&lt;/p&gt;

&lt;p&gt;This is just a snippet from the schema file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grammar {
  ComboBox = element ComboBox {
    attribute implements { text }?,
    attribute labelFunction { text }?,
    attribute labelField { xsd:string }?,
    attribute dropdownWidth { xsd:float }?
    ....
  }      
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;#39;m using named patterns here, because I need a pattern which matches
a choice of all possible components:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;any = Accordion
| AddChild
| AddChildAction
| AddItemAction
| AnimateProperty ....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why do I need this pattern? Well, all container components may have
child components and to enable this in the schema, the conteiner
elements have this pattern inside:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Application = element Application {
  any?,
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Problems&lt;/h3&gt;

&lt;p&gt;There are some known issues, which are not resolved yet. For example
the &lt;code&gt;Script&lt;/code&gt; tag may have a &lt;code&gt;CDATA&lt;/code&gt; element inside. Another ugly issue
is the color syntax. Inside the Flex framework a color is just an
integer, but we want to specify colors as hex values. Unfortunately
xsd:integer does not allow hex values, so I have to find a solution
for this some day.&lt;/p&gt;

&lt;h3&gt;Download&lt;/h3&gt;

&lt;p&gt;Download the &lt;a href=&quot;http://www.matthias-georgi.de/assets/download/flex3.rnc&quot;&gt;Relax NG Compact Schema for Adoble Flex 3&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Github&lt;/h3&gt;

&lt;p&gt;Watch or fork the &lt;a href=&quot;http://github.com/georgi/mxml-rnc&quot;&gt;Project on Github&lt;/a&gt;&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2008/9/relax-ng-schema-for-adobe-flex-3.html" type="text/html" />
    <published>01 Sep 08 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2008/9/quick-guide-for-passenger-on-ubuntu-hardy.html</id>
    <title type="text">Quick Guide for Passenger on Ubuntu Hardy</title>
    <updated>01 Sep 08 00:00</updated>
    <content type="html">&lt;p&gt;This is a short guide for installing &lt;a href=&quot;http://www.modrails.com/&quot;&gt;Phusion Passenger&lt;/a&gt; on Ubuntu
Hardy. This includes the installation of Ruby 1.8.6, Apache 2.2.8, 
MySQL 5.0.51a, Git 1.5.4 and Rails 2.1.1.&lt;/p&gt;

&lt;h3&gt;Essential Build Tools&lt;/h3&gt;

&lt;p&gt;First we need to install the compiler toolchain (make, gcc and libc).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install build-essential
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Git&lt;/h3&gt;

&lt;p&gt;This guide is based on Git, so we install the git package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install git-core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to host a git repository on this machine, initialize a new
repository:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir /var/git
$ mkdir /var/git/myapp
$ cd /var/git/myapp
$ git --bare init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can push your application code from your local machine to your
repository:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/myapp
$ git remote add origin ssh://myserver.com/var/git/myapp
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Ruby&lt;/h3&gt;

&lt;p&gt;We are going to install Ruby and all the essential ruby libraries.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install ruby ruby1.8-dev rubygems irb ri rdoc rake libruby libruby-extras
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Gem Executable Path&lt;/h3&gt;

&lt;p&gt;Strangely the &lt;em&gt;rubygems&lt;/em&gt; package does not setup the path for
executables, so we add the following line to &lt;code&gt;/etc/profile&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=/var/lib/gems/1.8/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To immediately use the new executable path, we source the profile file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ . /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Apache&lt;/h3&gt;

&lt;p&gt;This is just a basic Apache install. We need the devlopment files for compiling passenger:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install apache2 apache2-prefork-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;MySQL&lt;/h3&gt;

&lt;p&gt;I use MySQL, so I needed to install the server and client packages and
the Ruby gem, which compiles a native extension:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install mysql-server mysql-client
$ gem install mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Phusion Passenger&lt;/h3&gt;

&lt;p&gt;This is now the actual Passenger install, which consists of installing
a gem and compiling the Apache module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install passenger
$ passenger-install-apache2-module
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Apache configuration&lt;/h3&gt;

&lt;p&gt;The compilation of the Passenger Apache
module finished with an instruction for your httpd.conf. Depending on
you passenger version, you will get something like this, which you add
to your &lt;code&gt;/etc/apache2/httpd.conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoadModule passenger_module /var/lib/gems/1.8/gems/passenger-2.0.3/ext/apache2/mod_passenger.so
PassengerRoot /var/lib/gems/1.8/gems/passenger-2.0.3
PassengerRuby /usr/bin/ruby1.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Additionally you probably want to enable &lt;em&gt;mod_rewrite&lt;/em&gt;, which is
needed for Rails:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ a2enmod rewrite
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Installing your Rails app&lt;/h3&gt;

&lt;p&gt;We create a app folder in &lt;code&gt;/var/www&lt;/code&gt; and checkout the source from our
git repository:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /var/www
$ mkdir myapp
$ cd myapp
$ git init
$ git remote add origin /var/git/myapp
$ git pull origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Installing Rails&lt;/h4&gt;

&lt;p&gt;We don&amp;#39;t install Rails as Gem, because your application should be
pinned to a specific Rails version. Git submodules allow you to embed
a foreign repository in your source tree. &lt;/p&gt;

&lt;p&gt;We are now going to link the Rails repository to &lt;code&gt;vendor/rails&lt;/code&gt; and
checking out Version 2.1.1, finally we commit the submodule link to
our repository:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /var/www/myapp/
$ git submodule add git://github.com/rails/rails.git vendor/rails
$ cd vendor/rails
$ git checkout v2.1.1
$ cd ../..
$ git commit -m &amp;#39;linked rails as submodule&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Probably you need to setup your database:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mysaladmin create myapp_production
$ mysaladmin create myapp_development
$ mysaladmin create myapp_test
$ rake db:migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now your Rails app should be able to run as a Webrick Server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./script/server
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Virtual host&lt;/h3&gt;

&lt;p&gt;Adding a virtual host for your rails application is now super easy
thanks to Passenger. Create a file named
&lt;code&gt;/etc/apache2/sites-available/myapp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
    ServerName myserver.com
    DocumentRoot /var/www/myapp/public
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we disable the default site and add our new virtual host:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ a2dissite default
$ a2ensite myapp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After restarting Apache your Rails application should run on Apache:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /etc/init.d/apache2 restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;User authentication&lt;/h3&gt;

&lt;p&gt;In case your Rails app is not meant to be seen on public, I recommend
protecting it with HTTP Authentication.&lt;/p&gt;

&lt;p&gt;Create a password file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;htpasswd2 /var/www/myapp/config/auth myusername
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And add this to your virtual host configuration (Inside the
VirtualHost section):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Location /&amp;gt;
    AuthType Basic
    AuthName &amp;quot;My App&amp;quot;
    AuthUserFile /var/www/myapp/config/auth
    Require valid-user
&amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Phusion Passenger simplifies the Installation of Rails applications
significantly. I don&amp;#39;t have to worry about &lt;code&gt;mod_proxy&lt;/code&gt;,
&lt;code&gt;mod_proxy_balancer&lt;/code&gt;, &lt;code&gt;mongrel&lt;/code&gt; and &lt;code&gt;mongrel_cluster&lt;/code&gt; or even
FastCGI. This is &lt;strong&gt;definitely simpler&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;I have to mention, that Rails is just one option for your Ruby
application. Setting up any other Ruby framework should be possible
through the support of the &lt;a href=&quot;http://rack.rubyforge.org/&quot;&gt;Rack&lt;/a&gt; interface. &lt;/p&gt;

&lt;p&gt;I really hope, that the specification of using one &lt;em&gt;rackup file&lt;/em&gt; and
one &lt;em&gt;public folder&lt;/em&gt; will settle down as a standard for Ruby web
applications, so that hosting companies will focus on supporting this
standard and ruby developers don&amp;#39;t need to worry about finding support
for their favorite web frameworks.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2008/9/quick-guide-for-passenger-on-ubuntu-hardy.html" type="text/html" />
    <published>01 Sep 08 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2008/9/patroon-a-javascript-template-engine.html</id>
    <title type="text">Patroon - a Javascript Template Engine</title>
    <updated>01 Sep 08 00:00</updated>
    <content type="html">&lt;p&gt;Patroon is a template engine written in Javascript in about 100 lines
of code. It takes existing DOM nodes annotated with CSS classes and
expand a data object according to simple rules. Additionally you may
use traditional string interpolation inside attribute values and text
nodes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;
Patroon has its own &lt;a href=&quot;/patroon&quot;&gt;project page&lt;/a&gt; now!
Please look for current information there.
&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Example&lt;/h3&gt;

&lt;p&gt;Comments in this blog are stored as a list of JSON objects, I wrote about it &lt;a href=&quot;http://www.matthias-georgi.de/commenting-system-with-lightweight-json-store.html&quot;&gt;here&lt;/a&gt;. So think about a data object like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var data = { 
  comment: [{
    date: &amp;quot;2008-09-07 12:28:33&amp;quot;, 
    name: &amp;quot;David Beckham&amp;quot;,
    website: &amp;quot;beckham.com&amp;quot;,
    text: &amp;quot;I watched the euro finals on tv...&amp;quot; 
  }, { 
    date: &amp;quot;2008-09-07 14:28:33&amp;quot;, 
    name: &amp;quot;Tuncay&amp;quot;,
    website: &amp;quot;&amp;quot;,
    text: &amp;quot;Me too&amp;quot;
  }]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This data will be expanded with help of following template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;comments&amp;quot;&amp;gt;  
  &amp;lt;div id=&amp;quot;comments-template&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;comment&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;_ top&amp;quot;&amp;gt;
        &amp;lt;a class=&amp;quot;_&amp;quot; href=&amp;quot;{website}&amp;quot;&amp;gt;{name}&amp;lt;/a&amp;gt; said
        &amp;lt;a class=&amp;quot;_&amp;quot; title=&amp;quot;{time}&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;:
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;text&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;   
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The javascript to actually execute this template looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The comments template will be removed from the DOM!
var template = new Template(&amp;#39;comments-template&amp;#39;);

// template will result in a new DOM node
var result = template.expand(data);

// insert the resulting node into the comments container
var container = document.getElementsByClassName(&amp;#39;comments&amp;#39;)[0];
container.appendChild(result);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using jQuery the code gets a bit cleaner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The comments template will be removed from the DOM!
var template = new Template(&amp;#39;comments-template&amp;#39;);

// Expand the template into the comments section
$(&amp;#39;.comments&amp;#39;).expand(template, data);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Basic Rules&lt;/h3&gt;

&lt;p&gt;There are 5 basic rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Strings and Numbers are inserted by innerHTML to the current node.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Arrays repeat the current node and process its elements recursively in same scope.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Objects trigger a class name lookup by property name. The value of each property is expanded recursively in new scope.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code will be evaluated for text surounded with braces (Works also for attributes).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Processing child nodes will be triggered for nodes with a class attribute starting with &lt;code&gt;_&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I admit the last point is a bit quirky, but processing all child nodes per default is too expensive and too unpredictable. Maybe I will find a better way, but I don’t mind inserting these extra &lt;code&gt;_&lt;/code&gt; class names.&lt;/p&gt;

&lt;h3&gt;Evaluation&lt;/h3&gt;

&lt;p&gt;So speaking of the example data, this would mean following algorithm:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Find the first node with a class name of comment.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Repeat this node two times and recursively process the first and second comment.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Descend into the node with class &lt;code&gt;top&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Descend into the first link node.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Evaluate the code found in the &lt;em&gt;href&lt;/em&gt; attribute and in the text.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Descend into the second link node.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Evaluate the code found in the &lt;em&gt;title&lt;/em&gt; attribute.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Find the first node with the class &lt;code&gt;text&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Insert the the text of the comment into the found node.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that we are dealing with two scopes here: the global scope and the comment scope. The global scope just contains a name &lt;em&gt;comment&lt;/em&gt; and the comment scope contains the names &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;website&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Download&lt;/h3&gt;

&lt;p&gt;Download the script at my &lt;a href=&quot;http://github.com/georgi/patroon/tree/master&quot;&gt;github repository&lt;/a&gt;.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2008/9/patroon-a-javascript-template-engine.html" type="text/html" />
    <published>01 Sep 08 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2008/9/patroon-a-javascript-template-engine-part-2.html</id>
    <title type="text">Patroon - a Javascript Template Engine (Part 2)</title>
    <updated>01 Sep 08 00:00</updated>
    <content type="html">&lt;p&gt;This post is an update to my &lt;a href=&quot;http://www.matthias-georgi.de/2008/9/patroon-a-javascript-template-engine.html&quot;&gt;initial post&lt;/a&gt;. Patroon has been
improved and is now easier to use and uses a better algorithm
internally.&lt;/p&gt;

&lt;p&gt;Patroon is a template engine written in Javascript in about 130 lines
of code. It takes existing DOM nodes annotated with class names and
expand a data object according to simple rules. Additionally you may
use traditional string interpolation inside attribute values and text
nodes.&lt;/p&gt;

&lt;h3&gt;The Data&lt;/h3&gt;

&lt;p&gt;Comments in this blog are stored as a list of JSON objects, I wrote
about it &lt;a href=&quot;http://www.matthias-georgi.de/2008/9/commenting-system-with-lightweight-json-store.html&quot;&gt;here&lt;/a&gt;. So think about a data object like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var data = { 
  comment: [{
    time: &amp;quot;2008-09-07 12:28:33&amp;quot;, 
    name: &amp;quot;David Beckham&amp;quot;,
    website: &amp;quot;beckham.com&amp;quot;,
    text: &amp;quot;I watched the euro finals on tv...&amp;quot; 
  }, { 
    time: &amp;quot;2008-09-07 14:28:33&amp;quot;, 
    name: &amp;quot;Tuncay&amp;quot;,
    website: &amp;quot;&amp;quot;,
    text: &amp;quot;Me too&amp;quot;
  }]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;The Template&lt;/h3&gt;

&lt;p&gt;This data will be expanded with help of following template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;comments&amp;quot;&amp;gt;  
  &amp;lt;div id=&amp;quot;comments-template&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;comment&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;top&amp;quot;&amp;gt;
        {website.length &amp;gt; 0 ? linkTo(name, website) : name} said
        &amp;lt;a title=&amp;quot;{time}&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;:
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;text&amp;quot;&amp;gt;
        {text}
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;   
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Usage&lt;/h3&gt;

&lt;p&gt;The javascript to actually execute this template looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The comments template will be removed from the DOM!
var template = new Template(&amp;#39;comments-template&amp;#39;);

// Expand the template into the comments section
$(&amp;#39;.comments&amp;#39;).expand(template, data);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;#39;t want to use jQuery, please look at the end of this article.&lt;/p&gt;

&lt;h3&gt;Output&lt;/h3&gt;

&lt;p&gt;The given example renders following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;comments&amp;quot;&amp;gt;  
  &amp;lt;div id=&amp;quot;comments-template&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;comment&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;top&amp;quot;&amp;gt;
        &amp;lt;a href=&amp;quot;http://backham.com&amp;quot;&amp;gt;David Beckham&amp;lt;/a&amp;gt; said
        &amp;lt;a title=&amp;quot;2008-09-07 12:28:33&amp;quot;&amp;gt;2 hours ago&amp;lt;/a&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;text&amp;quot;&amp;gt;
        I watched the euro finals on tv...
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;   
    &amp;lt;div class=&amp;quot;comment&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;top&amp;quot;&amp;gt;
        Tuncay said
        &amp;lt;a title=&amp;quot;2008-09-07 14:28:33&amp;quot;&amp;gt;1 minute ago&amp;lt;/a&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;text&amp;quot;&amp;gt;
        Me too
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;   
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Basic Rules&lt;/h3&gt;

&lt;p&gt;There are 3 basic rules regarding the evaluation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Each found class name of a node will be looked up in the current
data object. If found, the node will be processed in the new scope.
Example: the class name &lt;code&gt;comment&lt;/code&gt; instructs to lookup the name
&lt;code&gt;comment&lt;/code&gt; in the data object, which contains the comment array.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Arrays repeat the current node and process its elements recursively.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code will be evaluated for text surrounded with braces (works also
for attributes). The evaluation takes place in the scope of the
current data object, which is in the example a comment object. So
the snippet &lt;code&gt;&amp;lt;a title=&amp;quot;{time}&amp;quot;&amp;gt;&lt;/code&gt; will lookup the time in the comment
object and insert into the title attribute.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Helper&lt;/h3&gt;

&lt;p&gt;Code snippets inside the template will be executed within the scope of
a Helper object. If you want to extend it, just add your functions to
&lt;code&gt;Template.Helper&lt;/code&gt;. At the moment it defines only one function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Template.Helper = {

    linkTo: function(text, url) {
        if (url.indexOf(&amp;#39;http://&amp;#39;) == -1 &amp;amp;&amp;amp; url[0] != &amp;#39;/&amp;#39; &amp;amp;&amp;amp; url[0] != &amp;#39;#&amp;#39;) {
            url = &amp;#39;http://&amp;#39; + url;
        }
        return &amp;#39;&amp;lt;a href=&amp;quot;&amp;#39; + url +&amp;#39;&amp;quot;&amp;gt;&amp;#39; + text + &amp;#39;&amp;lt;/a&amp;gt;&amp;#39;;
    }

};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Examples&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.matthias-georgi.de/2008/9/using-javascript-templates-for-a-delicious-sidebar.html&quot;&gt;a Delicious Sidebar&lt;/a&gt;, which renders a &lt;em&gt;JSON&lt;/em&gt; feed with the help
of Patroon.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Download&lt;/h3&gt;

&lt;p&gt;Download the script at my &lt;a href=&quot;http://github.com/georgi/patroon/tree/master&quot;&gt;github repository&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Related Work&lt;/h3&gt;

&lt;p&gt;There are some other libraries for javascript templating, which are
related to &lt;strong&gt;Patroon&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://beebole.com/pure/&quot;&gt;PURE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jsrepeater.devprog.com/&quot;&gt;jsRepeater&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://code.google.com/p/trimpath/wiki/JavaScriptTemplates&quot;&gt;TrimPath&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://embeddedjs.com/&quot;&gt;EmbeddedJS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Patroon is probably the smallest templating solution around and
consists only of 130 lines of code.&lt;/p&gt;

&lt;h3&gt;Appendix&lt;/h3&gt;

&lt;p&gt;Without jQuery template expansion is a bit verbose:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@@javascript

// The comments template will be removed from the DOM!
var template = new Template(&amp;#39;comments-template&amp;#39;);

// template will result in a new DOM node
var result = template.expand(data);

// insert the resulting node into the comments container
var container = document.getElementsByClassName(&amp;#39;comments&amp;#39;)[0];
container.appendChild(result);
&lt;/code&gt;&lt;/pre&gt;
</content>
    <link href="http://www.matthias-georgi.de/2008/9/patroon-a-javascript-template-engine-part-2.html" type="text/html" />
    <published>01 Sep 08 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2008/9/emacs-completions.html</id>
    <title type="text">Emacs Completions with Hippie-Expand and Snippets</title>
    <updated>01 Sep 08 00:00</updated>
    <content type="html">&lt;p&gt;One of the most important features of a text editor is the completing
of text inside a buffer. There a lots of packages for Emacs, which
provide this feature in many different ways. I will show you, what I
use to improve my life as coder.&lt;/p&gt;

&lt;p&gt;&lt;EMBED SRC=&quot;/shockwaves/emacs-completion.swf&quot; WIDTH=400 HEIGHT=320 quality=low loop=false TYPE=&quot;application/x-shockwave-flash&quot; PLUGINSPAGE=&quot;http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash&quot;&gt;&lt;/p&gt;

&lt;h3&gt;Multifunctional tab key&lt;/h3&gt;

&lt;p&gt;Most of the time the tab key in Emacs is bound to the indentation
command, which will indent the current line. So if you want to use the
tab key for other things, you need some kind of multiplexer, which
tries to figure out, what is the right thing to do in each situation.&lt;/p&gt;

&lt;p&gt;So I copied the indent-and-complete from the &lt;a href=&quot;http://dima-exe.ru/rails-on-emacs&quot; title=&quot;Emacs Rails package&quot;&gt;emacs-rails package&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(require &amp;#39;hippie-exp)
(require &amp;#39;snippet)

(defun indent-and-complete ()
  &amp;quot;Indent line and complete&amp;quot;
  (interactive)

  (cond
   ((and (boundp &amp;#39;snippet) snippet)
    (snippet-next-field))

   ((looking-at &amp;quot;\\\\_&amp;gt;&amp;quot;)
    (hippie-expand nil))

   ((indent-for-tab-command))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function &lt;code&gt;indent-and-complete&lt;/code&gt; does one of the following actions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if a snippet is active, it jumps to the next field&lt;/li&gt;
&lt;li&gt;if we are at a word boundary, it tries to complete with &lt;code&gt;hippie-expand&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;otherwise it indents the current line&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;HTML mode initialization&lt;/h3&gt;

&lt;p&gt;Well, this function alone will not change your editor behaviour. For
activating our tab function, we need to bind the tab key.&lt;/p&gt;

&lt;p&gt;Additionally we want to setup &lt;code&gt;hippie-expand&lt;/code&gt;, an expansion package,
which will try to expand the word before the cursor in a configurable
way. &lt;code&gt;hippie-expand-try-functions-list&lt;/code&gt; is a variable, which defines a
list of functions, which should be called for completion.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s have a look at my &lt;code&gt;html-mode&lt;/code&gt; initialization function. It will configure
the completion behaviour of hippie-expand an bind the tab key to &lt;code&gt;indent-and-complete&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;; We need a simple wrapper for expand-abbrev
(defun try-expand-abbrev (old)
  (expand-abbrev))

;; ********************************************************************************
;; HTML Mode
;;
(add-to-list &amp;#39;auto-mode-alist &amp;#39;(&amp;quot;\\\\.html\\\\&amp;#39;&amp;quot; . html-mode))

(defun html-mode-on-init ()
  (set (make-local-variable &amp;#39;hippie-expand-try-functions-list)
       &amp;#39;(try-expand-abbrev
         try-expand-dabbrev))
  (define-key html-mode-map (kbd &amp;quot;&amp;lt;tab&amp;gt;&amp;quot;) &amp;#39;indent-and-complete))

(add-hook &amp;#39;html-mode-hook &amp;#39;html-mode-on-init)    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There a two functions, which will be asked to complete the current word:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;try-expand-abbrev&lt;/code&gt;: Expands the current word by looking into the
list of defined abbreviations. So called abbrevs are just shortcuts
in Emacs. So if you type &lt;code&gt;li&lt;/code&gt; and hit the tab key it will be
expanded to &lt;code&gt;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;try-expand-dabbrev&lt;/code&gt;: Dynamic abbreviation is a pragmatic method for
completing words. Emacs will look for words with the same beginning
and use them for completion. Hitting multiple times the tab key will
give you different completions, as you may know from the unix shell.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Defining your snippets&lt;/h3&gt;

&lt;p&gt;Now if you want to use snippets for your &lt;code&gt;html-mode&lt;/code&gt;, you have to
define a abbrev-table with your desired snippets. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-abbrev-table &amp;#39;html-mode-abbrev-table ())

(snippet-with-abbrev-table &amp;#39;html-mode-abbrev-table 
 (&amp;quot;h1&amp;quot;      . &amp;quot;&amp;lt;h1&amp;gt;$.&amp;lt;/h1&amp;gt;&amp;quot;)
 (&amp;quot;h2&amp;quot;      . &amp;quot;&amp;lt;h2&amp;gt;$.&amp;lt;/h2&amp;gt;&amp;quot;)
 (&amp;quot;h3&amp;quot;      . &amp;quot;&amp;lt;h3&amp;gt;$.&amp;lt;/h3&amp;gt;&amp;quot;)
 (&amp;quot;h4&amp;quot;      . &amp;quot;&amp;lt;h3&amp;gt;$.&amp;lt;/h4&amp;gt;&amp;quot;)
 (&amp;quot;h5&amp;quot;      . &amp;quot;&amp;lt;h3&amp;gt;$.&amp;lt;/h5&amp;gt;&amp;quot;)
 (&amp;quot;h6&amp;quot;      . &amp;quot;&amp;lt;h6&amp;gt;$.&amp;lt;/h6&amp;gt;&amp;quot;)
 (&amp;quot;div&amp;quot;     . &amp;quot;&amp;lt;div&amp;gt;$.&amp;lt;/div&amp;gt;&amp;quot;)
 (&amp;quot;divc&amp;quot;    . &amp;quot;&amp;lt;div class=\&amp;quot;$${class}\&amp;quot;&amp;gt;$.&amp;lt;/div&amp;gt;&amp;quot;)
 (&amp;quot;span&amp;quot;    . &amp;quot;&amp;lt;span&amp;gt;$.&amp;lt;/span&amp;gt;&amp;quot;)
 (&amp;quot;spans&amp;quot;   . &amp;quot;&amp;lt;span style=\&amp;quot;$${style}\&amp;quot;&amp;gt;$.&amp;lt;/span&amp;gt;&amp;quot;)
 (&amp;quot;form&amp;quot;    . &amp;quot;&amp;lt;form action=\&amp;quot;$${action}\&amp;quot; method=\&amp;quot;$${post}\&amp;quot;&amp;gt;$.&amp;lt;/form&amp;gt;&amp;quot;)
 (&amp;quot;input&amp;quot;   . &amp;quot;&amp;lt;input type=\&amp;quot;$${text}\&amp;quot; name=\&amp;quot;$${name}\&amp;quot; value=\&amp;quot;$${value}\&amp;quot;/&amp;gt;&amp;quot;)
 (&amp;quot;a&amp;quot;       . &amp;quot;&amp;lt;a href=\&amp;quot;$${href}\&amp;quot;&amp;gt;$.&amp;lt;/a&amp;gt;&amp;quot;)
 (&amp;quot;br&amp;quot;      . &amp;quot;&amp;lt;br/&amp;gt;$.&amp;quot;)
 (&amp;quot;ul&amp;quot;      . &amp;quot;&amp;lt;ul&amp;gt;$.&amp;lt;/ul&amp;gt;&amp;quot;)
 (&amp;quot;ol&amp;quot;      . &amp;quot;&amp;lt;ul&amp;gt;$.&amp;lt;/ul&amp;gt;&amp;quot;)
 (&amp;quot;li&amp;quot;      . &amp;quot;&amp;lt;li&amp;gt;$.&amp;lt;/li&amp;gt;&amp;quot;)
 (&amp;quot;tab&amp;quot;     . &amp;quot;&amp;lt;table&amp;gt;$.&amp;lt;/table&amp;gt;&amp;quot;)
 (&amp;quot;tr&amp;quot;      . &amp;quot;&amp;lt;tr&amp;gt;$.&amp;lt;/tr&amp;gt;&amp;quot;)
 (&amp;quot;td&amp;quot;      . &amp;quot;&amp;lt;td&amp;gt;$.&amp;lt;/td&amp;gt;&amp;quot;)
 (&amp;quot;th&amp;quot;      . &amp;quot;&amp;lt;th&amp;gt;$.&amp;lt;/th&amp;gt;&amp;quot;)
 (&amp;quot;str&amp;quot;     . &amp;quot;&amp;lt;strong&amp;gt;$.&amp;lt;/strong&amp;gt;&amp;quot;)
 (&amp;quot;em&amp;quot;      . &amp;quot;&amp;lt;em&amp;gt;$.&amp;lt;/em&amp;gt;&amp;quot;)
 (&amp;quot;meta&amp;quot;    . &amp;quot;&amp;lt;meta name=\&amp;quot;$${name}\&amp;quot; content=\&amp;quot;$${content}\&amp;quot;/&amp;gt;&amp;quot;)
 (&amp;quot;style&amp;quot;   . &amp;quot;&amp;lt;style type=\&amp;quot;text/css\&amp;quot;&amp;gt;$.&amp;lt;/style&amp;gt;&amp;quot;)
 (&amp;quot;script&amp;quot;  . &amp;quot;&amp;lt;script type=\&amp;quot;text/javascript\&amp;quot;&amp;gt;$.&amp;lt;/script&amp;gt;&amp;quot;)
 (&amp;quot;scripts&amp;quot; . &amp;quot;&amp;lt;script src=\&amp;quot;$${src}\&amp;quot; type=\&amp;quot;text/javascript\&amp;quot;&amp;gt;$.&amp;lt;/script&amp;gt;&amp;quot;)
 (&amp;quot;img&amp;quot;     . &amp;quot;&amp;lt;img src=\&amp;quot;$.\&amp;quot;/&amp;gt;&amp;quot;)
 (&amp;quot;link&amp;quot;    . &amp;quot;&amp;lt;link href=\&amp;quot;$${href}\&amp;quot; media=\&amp;quot;screen\&amp;quot; rel=\&amp;quot;stylesheet\&amp;quot; type=\&amp;quot;text/css\&amp;quot;/&amp;gt;&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great. If you put all the code in your .emacs file, you should be able
to use your tab key for completions. In our case we defined snippets
for the &lt;code&gt;html-mode&lt;/code&gt; and activated &lt;code&gt;hippie-expand&lt;/code&gt; to use abbrevs and
dynamic abbreviation. There is much more stuff I will show you next
time, like customizations for other language modes like &lt;em&gt;Ruby&lt;/em&gt; and
&lt;em&gt;Javascript&lt;/em&gt;.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2008/9/emacs-completions.html" type="text/html" />
    <published>01 Sep 08 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2008/9/commenting-system-with-lightweight-json-store.html</id>
    <title type="text">Commenting system with lightweight JSON store</title>
    <updated>01 Sep 08 00:00</updated>
    <content type="html">&lt;p&gt;As I wrote this &lt;a href=&quot;http://www.matthias-georgi.de/shinmun.html&quot;&gt;blog engine&lt;/a&gt;, the need for a commenting system
arose and I reflected about a small and simple commenting system with
just a flat file JSON store. This is my solution, which can be used on
any static page on a server with PHP support.&lt;/p&gt;

&lt;h3&gt;JQuery Frontend&lt;/h3&gt;

&lt;p&gt;First of all we need a form, which will post the data to the &lt;em&gt;PHP&lt;/em&gt;
script. The comment rendering is done by my own &lt;em&gt;Javascript&lt;/em&gt;
templating system, which I will explain in a seperate post. For now we
focus on the task of posting a form and saving it to our &lt;em&gt;JSON&lt;/em&gt; store.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;comment-form&amp;quot;&amp;gt;
    &amp;lt;form&amp;gt;
      &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;guid&amp;quot; value=&amp;quot;7ad04f10-5dd6-012b-b53c-001a92975b89&amp;quot;/&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;label&amp;gt;Name&amp;lt;/label&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot; size=&amp;quot;40&amp;quot;/&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;label&amp;gt;Website&amp;lt;/label&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;website&amp;quot;  size=&amp;quot;40&amp;quot;/&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;label&amp;gt;Comment&amp;lt;/label&amp;gt;&amp;lt;br/&amp;gt;
        &amp;lt;textarea name=&amp;quot;text&amp;quot; cols=&amp;quot;60&amp;quot; rows=&amp;quot;10&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post comment&amp;quot;/&amp;gt;
      &amp;lt;/p&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My blog engine generates a guid for each post, so this will be posted
by the form as well. Ok, let&amp;#39;s have a look at the Javascript code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&amp;#39;.comment-form form&amp;#39;).ajaxForm({
    url: Blog.root + &amp;#39;controllers/comments.php&amp;#39;,
    type: &amp;#39;POST&amp;#39;,
    resetForm: true,
    beforeSubmit: function(values) {
        if (values[1].value &amp;amp;&amp;amp; values[3].value) {
            return true;
        }
        else {
            alert(&amp;#39;Please enter name and text!&amp;#39;);
            return false;
        }
    },
    success: function(data) {
        renderComments(data);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This uses the &lt;a href=&quot;http://malsup.com/jquery/form/&quot;&gt;jquery-form plugin&lt;/a&gt; to submit the form via &lt;em&gt;AJAX&lt;/em&gt;,
nothing special here, the input will be validated to have at least a
name and comment text. After a successful comment post, the comments
should be rendered, but this is another story.&lt;/p&gt;

&lt;h3&gt;PHP Backend&lt;/h3&gt;

&lt;p&gt;The backend is extremely &lt;a href=&quot;http://en.wikipedia.org/wiki/You_Ain%27t_Gonna_Need_It&quot;&gt;YAGNI&lt;/a&gt;. Comments for one post, will be
saved in one JSON file like &lt;code&gt;comments/guid-of-the-post&lt;/code&gt;. The 4 fields
will be encoded as json array and appended to the file. This happens
only, if the request was a &lt;em&gt;POST&lt;/em&gt;. Finally we read the whole file and
send it back as response.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php

$guid_pattern = &amp;quot;/^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$/&amp;quot;;
$req = $_REQUEST;
$guid = $req[&amp;#39;guid&amp;#39;];

preg_match($guid_pattern, $guid) or die(&amp;quot;invalid guid&amp;quot;);

$file = &amp;#39;comments/&amp;#39; . $guid;

if ($_SERVER[&amp;#39;REQUEST_METHOD&amp;#39;] == &amp;#39;POST&amp;#39;) {   
  // create a comment record
  $record = array(date(&amp;#39;Y-m-d H:i:s&amp;#39;), 
                  strip_tags(stripslashes($req[&amp;#39;name&amp;#39;])),
                  strip_tags(stripslashes($req[&amp;#39;website&amp;#39;])),
                  strip_tags(stripslashes($req[&amp;#39;text&amp;#39;])));

  // encode as json string
  $json = json_encode($record) . &amp;quot;\n&amp;quot;;

  // open the comment file for appending
  $fp = fopen($file, &amp;quot;a&amp;quot;);

  // acquire a write lock
  flock($fp, LOCK_EX);

  // append the json line
  fwrite($fp, $json);

  // release lock
  flock($fp, LOCK_UN);

  // close file
  fclose($fp);
}

if (file_exists($file)) {    
  // open the comment file for reading
  $fp = fopen($file, &amp;quot;r&amp;quot;);

  // acquire a read lock
  flock($fp, LOCK_SH);

  // read whole file and print it out
  echo fread($fp, filesize($file));

  // release lock
  flock($fp, LOCK_UN);

  // close file
  fclose($fp);
}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One important thing to note is, that the comment file is not one big
JSON array. It looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;2008-09-07 12:28:33&amp;quot;,&amp;quot;Hans&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;**strong text**\n*emphasized text*&amp;quot;]
[&amp;quot;2008-09-07 12:29:33&amp;quot;,&amp;quot;Hans&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;**strong text**\n\n\n*emphasized text*&amp;quot;]
[&amp;quot;2008-09-07 12:29:56&amp;quot;,&amp;quot;Hans&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;**strong text**\n\n\n*emphasized text*&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For each line, we have one JSON array. This way, the &lt;em&gt;PHP&lt;/em&gt; script
doesn&amp;#39;t need to read the whole JSON thing into memory. It just appends
on every &lt;em&gt;POST&lt;/em&gt; one line.&lt;/p&gt;

&lt;h3&gt;Escaping&lt;/h3&gt;

&lt;p&gt;Some blog comments showed strange escaping behviour, so I investigated
further. PHP has a foolproof feature called &lt;a href=&quot;http://de.php.net/manual/en/security.magicquotes.php&quot;&gt;Magic Quotes&lt;/a&gt;. It
automatically escapes all dangerous characters from request parameters
to protect dumb users from &lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL Injection&lt;/a&gt;. This feature is
deprecated and in version 6.0.0 it will be removed. Nevertheless it is 
activated in a default PHP installation.&lt;/p&gt;

&lt;p&gt;To revert the escaping behaviour I have to call &lt;code&gt;stripslashes&lt;/code&gt;. Also I
have to care about stripping HTML tags from input. So to protect from
malicious HTML, I filter all input through &lt;code&gt;strip_tags&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Concurrency&lt;/h3&gt;

&lt;p&gt;As a commenter pointed out, concurrent access can be a headache. I
hoped, that &lt;code&gt;file_put_contents&lt;/code&gt; is an atomic function, but it is
not. However, I use a simple file locking scheme, which is good
enough. One caveat remains: in a multithreading environment this will
not work reliably. But I think, most PHP installations run as CGI, so
this will be ok.&lt;/p&gt;

&lt;h3&gt;Security&lt;/h3&gt;

&lt;p&gt;Seems that I had a serious security flaw in my first version. I didn&amp;#39;t
check the guid parameter, so that you could pass a path like 
&lt;code&gt;../../../../../../etc/group&lt;/code&gt;. Now the guid is matched against a regular
expression, so the script is now safe.&lt;/p&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;With a few lines you can hook up a simple commenting system for static
pages powered by &lt;em&gt;AJAX&lt;/em&gt; and &lt;em&gt;PHP&lt;/em&gt;. Note, that rendering of comments is
not discussed here and happens on &lt;em&gt;Javascript&lt;/em&gt; side. &lt;/p&gt;

&lt;p&gt;Read about my &lt;a href=&quot;http://www.matthias-georgi.de/patroon.html&quot;&gt;Javascript template engine&lt;/a&gt; which is used to render
the comments.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2008/9/commenting-system-with-lightweight-json-store.html" type="text/html" />
    <published>01 Sep 08 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2008/12/viewing-ri-in-a-web-browser.html</id>
    <title type="text">Viewing RI in a web browser</title>
    <updated>01 Dec 08 00:00</updated>
    <content type="html">&lt;p&gt;I&amp;#39;m a big fan of the Firefox keyword search. For example I have
keywords for &lt;a href=&quot;http://dict.leo.org&quot;&gt;LEO&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org&quot;&gt;Wikipedia&lt;/a&gt; and &lt;a href=&quot;http://www.nongnu.org/man2html&quot;&gt;Man pages&lt;/a&gt;. Sometimes I
want to look up API documentation in Ruby and typing &lt;code&gt;ri camelize&lt;/code&gt;
into the address bar and viewing the documentation as web page seems
to be quite natural for me. So I wrote a quick and dirty cgi, which
calls RI and outputs HTML.&lt;/p&gt;

&lt;h3&gt;CGI script&lt;/h3&gt;

&lt;p&gt;I&amp;#39;ve put the following code in file named
&lt;code&gt;/usr/lib/cgi-bin/ri.b&lt;/code&gt;. This is the default location for cgi scripts
on my system for Apache.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env ruby

require &amp;#39;rdoc/ri/ri_driver&amp;#39;
require &amp;#39;rubygems&amp;#39;

print &amp;quot;Content-type: text/html\r\n\r\n&amp;quot;

ARGV &amp;lt;&amp;lt; &amp;#39;-f&amp;#39; &amp;lt;&amp;lt; &amp;#39;html&amp;#39;

ri = RiDriver.new

print &amp;#39;&amp;lt;html&amp;gt;&amp;lt;body style=&amp;quot;width:600px; margin:auto; padding:20px&amp;quot;&amp;gt;&amp;#39;
ri.process_args
print &amp;#39;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script does the same thing as if you typed &lt;code&gt;ri somequery -f
html&lt;/code&gt;. I put some HTML around it to give it some style, but that&amp;#39;s it.&lt;/p&gt;

&lt;h3&gt;The Keyword Search&lt;/h3&gt;

&lt;p&gt;So I want to type &lt;code&gt;ri String.capitalize&lt;/code&gt; and the browser should send a
request to &lt;code&gt;http://localhost/cgi-bin/ri.rb?String.capitalize&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Just add a new bookmark and give it the keyword &lt;code&gt;ri&lt;/code&gt; and use as url
this one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; http://localhost/cgi-bin/ri.rb?%s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;#39;re done. One thing I would like to improve is to add hyperlinks
to the output. For example viewing the documentation of a class brings
up all documented methods. Each of them should be a link to the actual
documentation. Probably some monkey patching on the &lt;a href=&quot;http://rdoc.rubyforge.org/classes/RDoc/RI/HtmlFormatter.html&quot;&gt;HtmlFormatter&lt;/a&gt;
class would do the job.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2008/12/viewing-ri-in-a-web-browser.html" type="text/html" />
    <published>01 Dec 08 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2008/12/kontrol-a-micro-framework.html</id>
    <title type="text">Kontrol - a micro framework</title>
    <updated>01 Dec 08 00:00</updated>
    <content type="html">&lt;p&gt;Kontrol is a small web framework written in Ruby, which runs directly
on &lt;a href=&quot;http://github.com/chneukirchen/rack&quot;&gt;Rack&lt;/a&gt;. It provides a simple pattern matching algorithm for routing
and uses GitStore as data storage.&lt;/p&gt;

&lt;p&gt;All examples can be found in the &lt;a href=&quot;http://github.com/georgi/kontrol/tree/master/examples&quot;&gt;examples folder&lt;/a&gt; of the kontrol
project, which is hosted on &lt;a href=&quot;http://github.com/georgi/kontrol&quot;&gt;this github page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;
Kontrol has its own &lt;a href=&quot;/kontrol&quot;&gt;project page&lt;/a&gt; now!
Please look for current information there.
&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Quick Start&lt;/h3&gt;

&lt;p&gt;Create a file named &lt;code&gt;hello_world.ru&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;kontrol&amp;#39;

class HelloWorld &amp;lt; Kontrol::Application
  map do
    get &amp;#39;/&amp;#39; do
      &amp;quot;Hello World!&amp;quot; 
    end
  end
end

run HelloWorld.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rackup hello_world.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Browse to &lt;code&gt;http://localhost:9292&lt;/code&gt; and you will see &amp;ldquo;Hello World&amp;rdquo;.&lt;/p&gt;

&lt;h3&gt;Features&lt;/h3&gt;

&lt;p&gt;Kontrol is just a thin layer on top of Rack. It provides a routing
algorithm, a simple template mechanism and some convenience stuff to
work with &lt;a href=&quot;http://github.com/georgi/git_store&quot;&gt;GitStore&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A Kontrol application is a class, which provides some context to the
defined actions. You will probably use these methods:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;request: the Rack request object&lt;/li&gt;
&lt;li&gt;response: the Rack response object&lt;/li&gt;
&lt;li&gt;params: union of GET and POST parameters&lt;/li&gt;
&lt;li&gt;cookies: shortcut to request.cookies&lt;/li&gt;
&lt;li&gt;session: shortcut to &lt;code&gt;request.env[&amp;#39;rack.session&amp;#39;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;redirect(path): renders a redirect response to specified path&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Routing&lt;/h3&gt;

&lt;p&gt;Routing is just as simple as using regular expressions with
groups. Each group will be provided as argument to the block.&lt;/p&gt;

&lt;p&gt;Create a file named &lt;code&gt;routing.ru&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;kontrol&amp;#39;

class Routing &amp;lt; Kontrol::Application
  map do
    get &amp;#39;/pages/(.*)&amp;#39; do |name|
      &amp;quot;This is the page #{name}!&amp;quot;
    end

    get &amp;#39;/(\d*)/(\d*)&amp;#39; do |year, month|
      &amp;quot;Archive for #{year}/#{month}&amp;quot;
    end
  end
end

run Routing.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run this application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rackup routing.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will now see, how regex groups and parameters are related. For
example if you browse to &lt;code&gt;localhost:9292/2008/12&lt;/code&gt;, the app will
display &lt;code&gt;Archive for 2008/12&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Nested Routes&lt;/h3&gt;

&lt;p&gt;Routes can be nested. This way you can avoid repeating patterns and
define handlers for a set of HTTP verbs. Each handler will be called
with the same arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;kontrol&amp;#39;

class Nested &amp;lt; Kontrol::Application
  map do
    map &amp;#39;/blog&amp;#39; do
      get &amp;#39;/archives&amp;#39; do
        &amp;quot;The archives!&amp;quot;
      end
    end

    map &amp;#39;/(.*)&amp;#39; do
      get do |path|
        &amp;quot;&amp;lt;form method=&amp;#39;post&amp;#39;&amp;gt;&amp;lt;input type=&amp;#39;submit&amp;#39;/&amp;gt;&amp;lt;/form&amp;gt;&amp;quot;
      end

      post do |path|
        &amp;quot;You posted to #{path}&amp;quot;
      end
    end
  end
end

run Nested.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run this app like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rackup nested.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second route catches all paths except the &lt;code&gt;/blog&lt;/code&gt; route. Inside
the second route there are two different handlers for &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt;
actions.&lt;/p&gt;

&lt;p&gt;So if you browse to &lt;code&gt;/something&lt;/code&gt;, you will see a submit button. After
submitting you will see the result of the second handler.&lt;/p&gt;

&lt;h3&gt;Templates&lt;/h3&gt;

&lt;p&gt;Rendering templates is as simple as calling a template file with some
parameters, which are accessible inside the template as instance
variables. Additionally you will need a layout template.&lt;/p&gt;

&lt;p&gt;Create a template named &lt;code&gt;templates/layout.rhtml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;%= @content %&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now another template named &lt;code&gt;templates/page.rhtml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;&amp;lt;%= @title %&amp;gt;&amp;lt;/h1&amp;gt;
&amp;lt;%= @body %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a templates.ru file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Templates &amp;lt; Kontrol::Application
  map do
    get &amp;#39;/(.*)&amp;#39; do |name|
      render &amp;quot;page.rhtml&amp;quot;, :title =&amp;gt; name.capitalize, :body =&amp;gt; &amp;quot;This is the body!&amp;quot;
    end
  end
end

run Templates.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run this example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rackup templates.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you browse to any path on &lt;code&gt;localhost:9292&lt;/code&gt;, you will see the
rendered template. Note that the title and body parameters have been
passed to the &lt;code&gt;render&lt;/code&gt; call.&lt;/p&gt;

&lt;h3&gt;Using GitStore&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com/georgi/git_store&quot;&gt;GitStore&lt;/a&gt; is another library, which allows you to store code and
data in a convenient way in a git repository. The repository is
checked out into memory and any data may be saved back into the
repository.&lt;/p&gt;

&lt;p&gt;Install &lt;a href=&quot;http://github.com/georgi/git_store&quot;&gt;GitStore&lt;/a&gt; and &lt;a href=&quot;http://github.com/mojombo/grit&quot;&gt;Grit&lt;/a&gt; by:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem sources -a http://gems.github.com (you only have to do this once)
$ sudo gem install mojombo-grit georgi-git_store
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We create a Markdown file name &lt;code&gt;pages/index.md&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello World
===========

This is the **Index** page!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have now a simple page, which should be rendered as response. We
create a simple app in a file &lt;code&gt;git_app.ru&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &amp;#39;bluecloth&amp;#39;

class GitApp &amp;lt; Kontrol::Application
  map do
    get &amp;#39;/(.*)&amp;#39; do |name|
      BlueCloth.new(store[&amp;#39;pages&amp;#39;, name + &amp;#39;.md&amp;#39;]).to_html
    end
  end
end

run GitApp.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add all these files to your repo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git init
git add pages/index.md
git commit -m &amp;#39;init&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the app:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rackup git_app.ru
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Browse to &lt;code&gt;http://localhost:9292/index&lt;/code&gt; and you will see the rendered
page generated from the markdown file.&lt;/p&gt;

&lt;p&gt;This application runs straight from the git repository. You can delete
all files except the rackup file and the app will still serve the page
from your repo.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2008/12/kontrol-a-micro-framework.html" type="text/html" />
    <published>01 Dec 08 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2008/12/git-store-using-git-as-versioned-data-store-in-ruby.html</id>
    <title type="text">Git Store - using Git as versioned data store in Ruby</title>
    <updated>01 Dec 08 00:00</updated>
    <content type="html">&lt;p&gt;GitStore is a small Ruby library, providing an easy interface to the
version control system &lt;a href=&quot;http://git.or.cz/&quot;&gt;Git&lt;/a&gt;. It aims to use Git as a versioned
data store much like the well known PStore. Basically GitStore checks
out the repository into a in-memory representation, which can be
modified and finally committed. In this way your data is stored in a
folder structure and can be checked out and examined, but the
application may access the data in a convenient hash-like way. This
library is based on &lt;a href=&quot;http://github.com/mojombo/grit&quot;&gt;Grit&lt;/a&gt;, the main technology behind &lt;a href=&quot;http://github.com/&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;
GitStore has its own &lt;a href=&quot;/gitstore&quot;&gt;project page&lt;/a&gt; now!
Please look for current information there.
&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Installation&lt;/h3&gt;

&lt;p&gt;GitStore can be installed as gem easily, if you have RubyGems 1.2.0:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem sources -a http://gems.github.com (you only have to do this once)
$ sudo gem install mojombo-grit georgi-git_store
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;#39;t have RubyGems 1.2.0, you may download the package on the
&lt;a href=&quot;http://www.newartisans.com/blog_files/git.versioned.data.store.php&quot;&gt;github page&lt;/a&gt; and build the gem yourself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem build git_store.gemspec
$ sudo gem install git_store
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Usage Example&lt;/h3&gt;

&lt;p&gt;First thing you should do, is to initialize a new git repository.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir test
$ cd test
$ git init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can instantiate a GitStore instance and store some data. The
data will be serialized depending on the file extension. So for YAML
storage you can use the &amp;#39;yml&amp;#39; extension:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class WikiPage &amp;lt; Struct.new(:author, :title, :body); end
class User &amp;lt; Struct.new(:name); end

store = GitStore.new(&amp;#39;.&amp;#39;)

store[&amp;#39;users/matthias.yml&amp;#39;] = User.new(&amp;#39;Matthias&amp;#39;)
store[&amp;#39;pages/home.yml&amp;#39;] = WikiPage.new(&amp;#39;matthias&amp;#39;, &amp;#39;Home&amp;#39;, &amp;#39;This is the home page...&amp;#39;)

store.commit &amp;#39;Added user and page&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that directories will be created automatically.&lt;/p&gt;

&lt;p&gt;Another way to access a path is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;store[&amp;#39;config&amp;#39;, &amp;#39;wiki.yml&amp;#39;] = { &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;My Personal Wiki&amp;#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally you can access the git store as a Hash of Hashes, but in this
case you have to create the Tree objects manually:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;store[&amp;#39;users&amp;#39;] = GitStore::Tree.new
store[&amp;#39;users&amp;#39;][&amp;#39;matthias.yml&amp;#39;] = User.new(&amp;#39;Matthias&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Where is my data?&lt;/h3&gt;

&lt;p&gt;When you call the &lt;code&gt;commit&lt;/code&gt; method, your data is written back straight
into the git repository. No intermediate file representation. So if
you want to look into your data, you can use some git browser like
&lt;a href=&quot;http://www.kernel.org/pub/software/scm/git/docs/git-gui.html&quot;&gt;git-gui&lt;/a&gt; or just checkout the files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Iteration&lt;/h3&gt;

&lt;p&gt;Iterating over the data objects is quite easy. Furthermore you can
iterate over trees and subtrees, so you can partition your data in a
meaningful way. For example you may separate the config files and the
pages of a wiki:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;store[&amp;#39;pages/home.yml&amp;#39;] = WikiPage.new(&amp;#39;matthias&amp;#39;, &amp;#39;Home&amp;#39;, &amp;#39;This is the home page...&amp;#39;)
store[&amp;#39;pages/about.yml&amp;#39;] = WikiPage.new(&amp;#39;matthias&amp;#39;, &amp;#39;About&amp;#39;, &amp;#39;About this site...&amp;#39;)
store[&amp;#39;pages/links.yml&amp;#39;] = WikiPage.new(&amp;#39;matthias&amp;#39;, &amp;#39;Links&amp;#39;, &amp;#39;Some useful links...&amp;#39;)
store[&amp;#39;config/wiki.yml&amp;#39;] = { &amp;#39;name&amp;#39; =&amp;gt; &amp;#39;My Personal Wiki&amp;#39; }

store.each { |obj| ... } # yields all pages and the config hash
store[&amp;#39;pages&amp;#39;].each { |page| ... } # yields only the pages
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Serialization&lt;/h3&gt;

&lt;p&gt;Serialization is dependent on the filename extension. You can add more
handlers if you like, the interface is like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class YAMLHandler
  def read(id, name, data)
    YAML.load(data)
  end

  def write(data)
    data.to_yaml
  end    
end

GitStore::Handler[&amp;#39;yml&amp;#39;] = YAMLHandler.new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Shinmun uses its own handler for files with &lt;code&gt;md&lt;/code&gt; extension:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class PostHandler
  def read(name, data)
    Post.new(:filename =&amp;gt; name, :src =&amp;gt; data)
  end

  def write(post)
    post.dump
  end    
end

GitStore::Handler[&amp;#39;md&amp;#39;] = PostHandler.new
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Related Work&lt;/h3&gt;

&lt;p&gt;John Wiegley already has done &lt;a href=&quot;http://www.newartisans.com/blog_files/git.versioned.data.store.php&quot;&gt;something similar for Python&lt;/a&gt;. His
implementation has its own git interface, GitStore uses the wonderful
&lt;a href=&quot;http://github.com/mojombo/grit&quot;&gt;Grit&lt;/a&gt; library.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2008/12/git-store-using-git-as-versioned-data-store-in-ruby.html" type="text/html" />
    <published>01 Dec 08 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2007/5/google-like-search-results-helper.html</id>
    <title type="text">Google-like Search Results Helper</title>
    <updated>01 May 07 00:00</updated>
    <content type="html">&lt;p&gt;Representing your search results in a user-friendly way is a common
task among web developers. Google&amp;#39;s approach is dead simple but really
effective. The matching text is highlighted and shown with its
context. This can be implemented in less than 20 lines of code which
you can include into you helper:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def highlight_text(text, words)
  tokens = strip_tags(text).split
  sections = []
  words.each do |word|
    word = word.downcase
    tokens.each_with_index do |token, i|
      if token.downcase.include? word
        section = tokens[i-10, 20].join(&amp;#39; &amp;#39;)
        words.each do |word|
          section = highlight section, word
        end
        sections &amp;lt;&amp;lt; section + &amp;#39; ... &amp;#39;
        break if sections.size &amp;gt; 3          
      end
    end
  end
  sections.join
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we remove the html tags of the text and split the text into
tokens. Then we iterate over the search words and for each matching
token we generate a section, which contains the highlighted word. This
is done until we hav at least 4 sections, which are finally joined and
ready to be included into the search result template.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2007/5/google-like-search-results-helper.html" type="text/html" />
    <published>01 May 07 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2007/4/rendering-markaby-in-your-helpers.html</id>
    <title type="text">Rendering markaby in your helpers</title>
    <updated>01 Apr 07 00:00</updated>
    <content type="html">&lt;p&gt;Generating markup in your rails helpers is a general practice in rails
and is used throughout all rails helpers. Normally you use &lt;code&gt;content_tag&lt;/code&gt;
to generate markup. But often you will encounter situations, where
nested tags force you to write ugly helper code like the following
helper method from the rails library:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def options_for_select(container, selected = nil)
 container = container.to_a if Hash === container

 options_for_select = container.inject([]) do |options, element|
    if !element.is_a?(String) and element.respond_to?(:first) and element.respond_to?(:last)
     is_selected = ( (selected.respond_to?(:include?) &amp;amp;&amp;amp; !selected.is_a?(String) ? selected.include?(element.last) : element.last == selected) )
      if is_selected
       options &amp;lt;&amp;lt; &amp;quot;&amp;lt;option value=\&amp;quot;#{html_escape(element.last.to_s)}\&amp;quot; selected=\&amp;quot;selected\&amp;quot;&amp;gt;#{html_escape(element.first.to_s)}&amp;lt;/option&amp;gt;&amp;quot;
     else
       options &amp;lt;&amp;lt; &amp;quot;&amp;lt;option value=\&amp;quot;#{html_escape(element.last.to_s)}\&amp;quot;&amp;gt;#{html_escape(element.first.to_s)}&amp;lt;/option&amp;gt;&amp;quot;
     end
   else
     is_selected = ( (selected.respond_to?(:include?) &amp;amp;&amp;amp; !selected.is_a?(String) ? selected.include?(element) : element == selected) )
     options &amp;lt;&amp;lt; ((is_selected) ? &amp;quot;&amp;lt;option value=\&amp;quot;#{html_escape(element.to_s)}\&amp;quot; selected=\&amp;quot;selected\&amp;quot;&amp;gt;#{html_escape(element.to_s)}&amp;lt;/option&amp;gt;&amp;quot; : &amp;quot;&amp;lt;option value=\&amp;quot;#{html_escape(element.to_s)}\&amp;quot;&amp;gt;#{html_escape(element.to_s)}&amp;lt;/option&amp;gt;&amp;quot;)
   end
  end

 options_for_select.join(&amp;quot;\n&amp;quot;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Markaby Helper&lt;/h3&gt;

&lt;p&gt;We will now rewrite this code with inline markaby. We need therefore the following helper method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@@ruby

def markaby(&amp;amp;proc)
  assigns = {}
  instance_variables.each do |name|
    assigns[ name[1..-1] ] =  instance_variable_get(name)
  end
  Markaby::Builder.new(assigns, self).capture(&amp;amp;proc)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to collect the instance variables of the current template and
pass a hash of instance variable names along with their values to the
markaby builder. As second parameter we pass the current template, so
that the builder can access other helper methods. &lt;/p&gt;

&lt;h3&gt;Usage&lt;/h3&gt;

&lt;p&gt;Ok, let&amp;#39;s rewrite the &lt;code&gt;options_for_select&lt;/code&gt; helper. The method takes an
array of values which should be displayed as options. Alternatively
you may pass an list of pairs like &lt;code&gt;[[&amp;#39;first&amp;#39;,1],[&amp;#39;second&amp;#39;,2]&lt;/code&gt; or an
&lt;em&gt;Hash&lt;/em&gt;, which maps from option labels to their values. One thing I did
was to refactor the &lt;code&gt;is_selected test&lt;/code&gt; into a lambda. It is cleaner to
separate the test and probably more efficient. Inside the loop we are
testing, if we have pairs or simple values and generate markup by
sending the option method to the builder, which causes the markaby
builder to generate an option tag. Tag attributes are defined with a
hash, which we pass to the option method. A tag method takes an
optional block, which defines the content of a tag, in our case simply
the text of the option.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def options_for_select(container, selected = nil)
  container = container.to_a if Hash === container

  if selected.respond_to?(:include?) and !selected.is_a?(String)
    is_selected = lambda { |e| selected.include? e }
  else
    is_selected = lambda { |e| selected == e }
  end

  is_pair = lambda {|e| !e.is_a?(String) and e.respond_to?(:first) and e.respond_to?(:last) }

  markaby do
    container.each do |element|
      if is_pair[element]
        if is_selected[element.last]
          option(:value =&amp;gt; element.last, :selected =&amp;gt; &amp;#39;selected&amp;#39;) { h element.first }
        else
           option(:value =&amp;gt; element.last) { h element.first }
        end
      else
        if is_selected[element]
          option(:value =&amp;gt; element, :selected =&amp;gt; &amp;#39;selected&amp;#39;) { h element }
        else
          option(:value =&amp;gt; element) { h element }
        end
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Reusable helpers&lt;/h3&gt;

&lt;p&gt;Our defined markaby method is even more useful, we can accept a block
for our helper method and use it inside the markaby code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def tasks(&amp;amp;block)
  markaby do
    div.tasks {
      ul {
        markaby(&amp;amp;amp;block)
      }
    }
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we have a common pattern like a list of tasks for many templates,
we can generate the common code with the tasks method and put the
actual tasks in the block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tasks {
  task &amp;#39;Back to articles&amp;#39;.t, articles_url
  task :edit, @article
  task :versions, @article
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, you can see, there is also a task helper, which is defined as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def task(text, url_or_resource, html_options={})
  if text.is_a? Symbol
    task &amp;quot;#{text.to_s.humanize}&amp;quot;.t, {:action =&amp;gt; text, :id =&amp;gt; url_or_resource}, html_options
  else
    markaby { li { link_to text, url_or_resource, html_options } }
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the link text is a symbol, we are going to infer the url from the
action name which is the first parameter and the recource, which is
the second parameter in this case. Otherwise we generate a list
element and delegate the arguments to the &lt;code&gt;link_to helper&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;By using this simple abstraction, we have hidden the details of task
links. Instead of repeating the same pattern over and over again, we
have a common place to decide, how the tasks should look like. Markaby
makes it really easy to generate nested structures, as it takes
advantage of ruby&amp;#39;s block syntax.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2007/4/rendering-markaby-in-your-helpers.html" type="text/html" />
    <published>01 Apr 07 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2007/4/pretty-restful-urls-in-rails.html</id>
    <title type="text">Pretty RESTful URLs in Rails</title>
    <updated>01 Apr 07 00:00</updated>
    <content type="html">&lt;p&gt;Since Release 1.2 Rails knows to generate &lt;em&gt;RESTful&lt;/em&gt; routes. Each
resource is identified by an &lt;em&gt;URI&lt;/em&gt;, which looks like &lt;code&gt;/users/123&lt;/code&gt; . It
would be nice to have more readable URLs, which include the name of
the user: &lt;code&gt;/users/matthias-georgi&lt;/code&gt;. This is a short tutorial on making
your urls pretty while retaining the REST approach.&lt;/p&gt;

&lt;p&gt;Assuming that you already have an user model, we add following line to
our &lt;code&gt;config/routes.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;map.resources :users
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may now run the &lt;code&gt;scaffold_resource&lt;/code&gt; generator in case you don&amp;#39;t have
any &lt;code&gt;UsersController&lt;/code&gt; yet. In order to remember the &lt;em&gt;permalink&lt;/em&gt; for each
user, we store it in a column named &lt;code&gt;permalink&lt;/code&gt; in the users
table. Before we save an user record, we have to infer a url-safe
permalink for the user name. We do this by:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def before_save
  self.permalink = name.downcase.gsub(/[^a-z0-9]+/i, &amp;#39;-&amp;#39;) if permalink.blank?
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each character, which is not an &lt;em&gt;alphanumeric&lt;/em&gt; will be replaced by a
dash. This is only done, if the permalink is not set already. So we
have a way for users to set their permalink manually. To avoid
duplicate permalinks, we &lt;em&gt;validate&lt;/em&gt; the uniqeness of the permalink:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;validates_uniqeness_of :permalink
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happens now, if we browse to a user url like
&lt;code&gt;/users/matthias-georgi&lt;/code&gt; ? Rails raises an exception, telling us that it
cannot find an record with the id &lt;code&gt;matthias-georgi&lt;/code&gt;. We&amp;#39;ll fix now our
controller to look for the permalink and not the id of the user. Just
replace each call to &lt;code&gt;User.find(params[:id])&lt;/code&gt; with
&lt;code&gt;User.find_by_permalink(params[:id])&lt;/code&gt;. Also we have to ensure, that our
user routes will be generated correctly. Therefore we overwrite the
&lt;code&gt;to_param&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def to_param
  permalink
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The effect of this little change is, that &lt;code&gt;user_url(a_user)&lt;/code&gt; generates
the right url. &lt;em&gt;Nested resources&lt;/em&gt; and &lt;em&gt;pretty urls&lt;/em&gt; can get tricky and for
now I won&amp;#39;t touch this topic. Remember that &lt;em&gt;changing&lt;/em&gt; the permalink may
be problematic as links to the old url will get invalid. Nevertheless
have fun experimenting with pretty urls and the new wonderful world of
REST.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2007/4/pretty-restful-urls-in-rails.html" type="text/html" />
    <published>01 Apr 07 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2007/4/fast-autocompletion-with-rails.html</id>
    <title type="text">Fast Auto-completion with Rails, Scriptaculous and JSON</title>
    <updated>01 Apr 07 00:00</updated>
    <content type="html">&lt;p&gt;Inspired by the excellent &lt;a href=&quot;http://www.pragmaticprogrammer.com/titles/fr_rr/&quot;&gt;Rails Recipes&lt;/a&gt; book , I created an
improved Auto-completion helper, which uses &lt;em&gt;JSON&lt;/em&gt; and &lt;em&gt;AJAX&lt;/em&gt; instead
of a script tag for loading the completions. What we want to achieve
is a search field, which pops up immediately, showing us a list of
possible completions for our search word. Look at &lt;a href=&quot;http://labs.google.com/suggest/&quot;&gt;Google Suggest&lt;/a&gt;
to get an idea.&lt;/p&gt;

&lt;h3&gt;Rails Autocomplete&lt;/h3&gt;

&lt;p&gt;Rails already has an &lt;code&gt;auto_complete_field&lt;/code&gt;, which sends an AJAX
request for each keystroke. This approach is quite slow, but works in
most cases, especially for large datasets &lt;code&gt;auto_complete_field&lt;/code&gt; is the
better choice. Our idea, stolen from the Rails Recipes book is to
fetch the array of possible completions only once. Each keystroke will
trigger only a local lookup and need no further server interaction.&lt;/p&gt;

&lt;p&gt;Scriptaculous already has the right tool for this job:
&lt;a href=&quot;http://wiki.script.aculo.us/scriptaculous/show/Autocompleter.Local&quot;&gt;Autocompleter.Local&lt;/a&gt;.  We will just pass a javascript array of
possible completions to the constructor and we&amp;#39;re done.&lt;/p&gt;

&lt;h3&gt;CSS&lt;/h3&gt;

&lt;p&gt;OK, let&amp;#39;s start. First we need the CSS used by &lt;code&gt;Autocompleter.Local&lt;/code&gt;,
which styles the choices box:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@@css

div.auto_complete {
  width: 350px;
  background: #fff;
}

div.auto_complete ul {
  border:1px solid #888;
  margin:0;
  padding:0;
  width:100%;
  list-style-type:none;
}

div.auto_complete ul li {
  margin:0;
  padding:3px;
}

div.auto_complete ul li.selected {
  background-color: #ffb;
}

div.auto_complete ul strong.highlight {
  color: #800;
  margin:0;
  padding:0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Controller&lt;/h3&gt;

&lt;p&gt;Rails already has an controller macro for generating a auto completion
action. We will create a similar macro, which will generate an action,
which in turn generates the &lt;em&gt;JSON&lt;/em&gt; response. Sounds complex, but the
implementation is quite easy. Just add to your ApplicationController:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def self.fast_auto_complete_for(object, method, options = {})
 define_method(&amp;quot;auto_complete_for_#{object}_#{method}&amp;quot;) do
   render :json =&amp;gt; object.to_s.camelize.constantize.find(:all).map(&amp;amp;method).to_json
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The response of the generated action will now contain a list of all
values for the desired attribute. You can use it like in your
controllers: &lt;code&gt;fast_auto_complete_for :sport, :name&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;Javascript Helper&lt;/h3&gt;

&lt;p&gt;Now let us get into the tricky part: the javascript macro helper. How
will we get the completion list? &lt;em&gt;Prototype&lt;/em&gt; includes the &lt;code&gt;Ajax.Request&lt;/code&gt;
class, which sends an Ajax Request to our generated action and fetches
the array encoded as &lt;em&gt;JSON&lt;/em&gt;. Furthermore we have to generate a div which
will hold the popup list for our completion entries. Without going
into detail, I&amp;#39;ll just show you the code, which you add to your
&lt;code&gt;ApplicationHelper&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def fast_auto_complete_field(field_id, options={})
  div_id = &amp;quot;#{field_id}_auto_complete&amp;quot;
  url = options.delete(:url) or raise &amp;quot;url required&amp;quot;
  options = options.merge(:tokens =&amp;gt; &amp;#39;,&amp;#39;, :frequency =&amp;gt; 0 )
  script = javascript_tag &amp;lt;&amp;lt;-end
    new Ajax.Request(&amp;#39;#{url}&amp;#39;, {
      method: &amp;#39;get&amp;#39;,
      onSuccess: function(transport) {
        new Autocompleter.Local(&amp;#39;#{field_id}&amp;#39;, &amp;#39;#{div_id}&amp;#39;, eval(transport.responseText), #{options.to_json});
      }
    });
  end
  content_tag &amp;#39;div&amp;#39;, script, :class =&amp;gt; &amp;#39;auto_complete&amp;#39;, :id =&amp;gt; div_id
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our helper needs the id for the text field we want to enhance. Based
on this id the helper generates the div for presenting the completion
entries. It is also required to pass the url of the json action, which
is in our case &lt;code&gt;/sports/auto_complete_for_sport_name&lt;/code&gt;. &lt;/p&gt;

&lt;h3&gt;Usage example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot; id=&amp;quot;sport_name&amp;quot;/&amp;gt;
  &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Search&amp;quot;/&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;%= fast_auto_complete_field :sport_name, :url =&amp;gt; &amp;#39;/sports/auto_complete_for_sport_name&amp;#39; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, that&amp;#39;s it. Now you may enjoy snappy auto-completion and feel
good about using bleeding edge technology like &lt;code&gt;AJAX&lt;/code&gt; and &lt;code&gt;JSON&lt;/code&gt;.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2007/4/fast-autocompletion-with-rails.html" type="text/html" />
    <published>01 Apr 07 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2007/4/dry-up-your-url-helpers.html</id>
    <title type="text">DRY Up Your Url Helpers</title>
    <updated>01 Apr 07 00:00</updated>
    <content type="html">&lt;p&gt;This tutorial shows you how to simplify url generation in combination
with &lt;em&gt;RESTful&lt;/em&gt; resources by extending the &lt;code&gt;url_for&lt;/code&gt; helper. This approach
will also work with nested routes and other helpers like &lt;code&gt;form_tag&lt;/code&gt; and
&lt;code&gt;link_to&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One of the concepts of &lt;em&gt;REST&lt;/em&gt; is: each resource has its own unique
&lt;em&gt;URI&lt;/em&gt;. We will enhance the &lt;code&gt;url_for&lt;/code&gt; helper to generate this unique URI
for an arbitrary record.&lt;/p&gt;

&lt;h3&gt;Example Models&lt;/h3&gt;

&lt;p&gt;First we need a simple example. We have 2 models: &lt;code&gt;User&lt;/code&gt; and
&lt;code&gt;Article&lt;/code&gt;. For our url generation to work we have to add following code
to our models:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class User
      has_many :articles

      def to_params
        {:id =&amp;gt; permalink}
      end
    end

    class Article
      belongs_to :user

      def to_params
        {:user_id =&amp;gt; user.permalink, :id =&amp;gt; permalink}
      end
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is necessary for nested routes to play nicely with our url
generation code. We are now able to find the parameters for each
record to generate an unique URL.&lt;/p&gt;

&lt;h3&gt;Pretty URLs&lt;/h3&gt;

&lt;p&gt;In a previous post I demonstrated the use of meaningful urls. We are
going now the same way.&lt;/p&gt;

&lt;p&gt;Users are identified by an URL like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/users/matthias-georgi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each user may write articles, which are located at:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/users/matthias-georgi/articles
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I want to write a new article, I will use this URL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/users/matthias-georgi/articles/new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Editing an existing article would end up on this URL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/users/matthias-georgi/articles/my-first-post;edit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For nested resources to get working you define in config/routes.rb:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;map.resources :users do |user|
  user.resources :articles
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The traditional way to generate urls is to call the resource helpers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;article_url(article.user, article)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is redundant, as the article already knows its user.&lt;/p&gt;

&lt;h3&gt;The Resource Helper&lt;/h3&gt;

&lt;p&gt;Add following module into your lib folder and include the module in
both your application controller and application helper. The most
important bit is the url_for method. It will automatically generate
the right url for your resource.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module ResourceHelper

  def plural_class_name(record)
    singular_class_name(record).pluralize
  end

  def singular_class_name(record)
    record.class.name.underscore.tr(&amp;#39;/&amp;#39;, &amp;#39;_&amp;#39;)
  end

  def params_for(record)
    if record.respond_to?(:to_params)
      record.to_params
    else
      {:id =&amp;gt; record.to_param}
    end
  end

  def collection_url(collection, record, options)
    if record
      params = params_for(record)
      params[&amp;quot;#{singular_class_name(record)}_id&amp;quot;.to_sym] = params.delete(:id)
      url_for options.merge(params).merge(:controller =&amp;gt; collection)
    else
      url_for options.merge(:controller =&amp;gt; collection)
    end
  end

  def member_url(record, options)
    url_for options.merge(params_for(record)).merge(:controller =&amp;gt; plural_class_name(record))
  end

  def url_for(*args)
    if [String, Hash].any? {|type| args.first.is_a? type }
      super(*args)
    else
      if args[0].is_a?(Symbol)
        collection_url(args[0], args[1], :action =&amp;gt; &amp;#39;index&amp;#39;)
      else
        member_url(args.first, :action =&amp;gt; &amp;#39;show&amp;#39;)
      end
    end
  end

  def new_url_for(collection, record=nil)
    collection_url(collection, record, :action =&amp;gt; &amp;#39;new&amp;#39;)
  end

  def edit_url_for(record)
    member_url(record, :action =&amp;gt; &amp;#39;edit&amp;#39;)
  end

  def path_for(*args)
    if args[0].is_a?(Symbol)
      collection_url(args[0], args[1], :action =&amp;gt; &amp;#39;index&amp;#39;, :only_path =&amp;gt; true)
    else
      member_url(args.first, :action =&amp;gt; &amp;#39;show&amp;#39;, :only_path =&amp;gt; true)
    end
  end

  def new_path_for(collection, record=nil)
    collection_url(collection, record, :action =&amp;gt; &amp;#39;new&amp;#39;, :only_path =&amp;gt; true)
  end

  def edit_path_for(record)
    member_url(record, :action =&amp;gt; &amp;#39;edit&amp;#39;, :only_path =&amp;gt; true)
  end

end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Usage&lt;/h3&gt;

&lt;p&gt;So how can you use this stuff actually?&lt;/p&gt;

&lt;p&gt;It is pretty easy: just pass the record instead of the url hash and
the unique url will be generated automatically.&lt;/p&gt;

&lt;p&gt;The url of a collection is treated differently. You have to pass the
name of the collection, which is the controller name. For nested
resources you have to pass additionally the record, the collection is
belonging to.&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new_path_for(:users)          # =&amp;gt; &amp;#39;/users/new&amp;#39;
path_for(user)                # =&amp;gt; &amp;#39;/users/harald&amp;#39;
edit_path_for(user)           # =&amp;gt; &amp;#39;/users/harald;edit&amp;#39;
path_for(:articles, user)     # =&amp;gt; &amp;#39;/users/harald/articles&amp;#39;
new_path_for(:articles, user) # =&amp;gt; &amp;#39;/users/harald/articles/new&amp;#39;
path_for(article)             # =&amp;gt; &amp;#39;/users/harald/articles/article-1&amp;#39;
edit_path_for(article)        # =&amp;gt; &amp;#39;/users/harald/articles/article-1;edit&amp;#39;

# This works for helpers like url_for, form_tag or link_to. 

link_to article.title, article
form_tag :articles
form_tag article, :method =&amp;gt; &amp;#39;put&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If anybody is interested I will release this stuff as plugin. I think
other helpers could benefit as well as you can pass your records
around and each helper may generate the appropriate url.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2007/4/dry-up-your-url-helpers.html" type="text/html" />
    <published>01 Apr 07 00:00</published>
  </entry>
  <entry>
    <id>http://www.matthias-georgi.de/2007/4/building-delicous-and-flickr-sidebar-in-5-minutes.html</id>
    <title type="text">Building a del.ico.us and flickr sidebar in 5 minutes</title>
    <updated>01 Apr 07 00:00</updated>
    <content type="html">&lt;p&gt;You need a del.icio.us sidebar which shows recent bookmarks or one of
these nice flickr badges? This is really is easy as the &lt;a href=&quot;http://trac.typosphere.org/&quot;&gt;Typo Weblog
Engine&lt;/a&gt; already includes an flickr and del.icio.us aggregator.&lt;/p&gt;

&lt;p&gt;Download the files &lt;a href=&quot;http://trac.typosphere.org/browser/trunk/vendor/plugins/delicious_sidebar/lib/delicious.rb?format=raw&quot;&gt;delicous.rb&lt;/a&gt; and &lt;a href=&quot;http://trac.typosphere.org/browser/trunk/vendor/plugins/flickr_sidebar/lib/flickr.rb?format=raw&quot;&gt;flickr.rb&lt;/a&gt; and drop them
into your rails lib folder.&lt;/p&gt;

&lt;p&gt;Now add these two little helpers to your application_helper.rb:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    require &amp;#39;delicious&amp;#39;
    require &amp;#39;flickr&amp;#39;

    def delicious(tag)
      Delicious.new(&amp;quot;http://del.icio.us/rss/tag/#{tag}&amp;quot;)
    end

    def flickr(tag)
      url = &amp;quot;http://api.flickr.com/services/feeds/photos_public.gne?&amp;quot;
      url &amp;lt;&amp;lt; &amp;quot;tags=#{tag}&amp;amp;format=rss_200&amp;quot;
      FlickrAggregation.new(url)
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are now able to fetch the feeds for our desired tags with a simple
method call. Next step is to render a list of links for our
sidebar. So for rendering the del.icio.us sidebar, you need something
like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;ul&amp;gt;
      &amp;lt;% for item in delicious(:ruby).items[0, 10] %&amp;gt;
        &amp;lt;li&amp;gt;
          &amp;lt;%= link_to item.title, item.link %&amp;gt;
        &amp;lt;/li&amp;gt;
      &amp;lt;% end %&amp;gt;
    &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty self-explanatory. We take the first ten items of the
del.icio.us feed and for each item we output a list element containing
a link to the item. The view for the flickr badge is similar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;ul&amp;gt;
      &amp;lt;% for item in flickr(:ruby).pics[0, 10] %&amp;gt;
       &amp;lt;%= image_tag item.square, :size =&amp;gt; &amp;#39;48x48&amp;#39; %&amp;gt;
      &amp;lt;% end %&amp;gt;
    &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We take the first ten items of the flickr feed and for each item we
render an image tag which shows a square thumbnail of the size
48x48. Congratulations, you have just written a del.icio.us and flickr
sidebar in 5 minutes using only 18 lines of code. Now you can spend
the rest of the day pimping up your sidebar with all kinds of feeds
using one of these plugins of the typo weblog.&lt;/p&gt;
</content>
    <link href="http://www.matthias-georgi.de/2007/4/building-delicous-and-flickr-sidebar-in-5-minutes.html" type="text/html" />
    <published>01 Apr 07 00:00</published>
  </entry>
</feed>