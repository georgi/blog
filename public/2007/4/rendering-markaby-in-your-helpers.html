<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">

<html>
    <head>
        <title>
            Matthias Georgi
        </title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="alternate" type="application/atom+xml" href="http://feeds.feedburner.com/matthias-georgi" title="Atom 1.0">
        <link rel="stylesheet" media="screen" type="text/css" href="/style.css">
        <link rel="stylesheet" href="/zenburn.css">
        <script src="/highlight.pack.js">
            
        </script>
        <script>
            hljs.initHighlightingOnLoad();
        </script>
    </head>
    <body>
        <div class="container">
            <h2 id="header">
                <a href="/">
                    Matthias Georgi
                </a>
            </h2>
            <div class="content">
                <div class="article">
                    <h1>
                        <a href="/2007/4/rendering-markaby-in-your-helpers.html">
                            Rendering markaby in your helpers
                        </a>
                    </h1>
                    <p>Generating markup in your rails helpers is a general practice in rails
and is used throughout all rails helpers. Normally you use <code>content_tag</code>
to generate markup. But often you will encounter situations, where
nested tags force you to write ugly helper code like the following
helper method from the rails library:</p>

<pre><code>def options_for_select(container, selected = nil)
 container = container.to_a if Hash === container

 options_for_select = container.inject([]) do |options, element|
    if !element.is_a?(String) and element.respond_to?(:first) and element.respond_to?(:last)
     is_selected = ( (selected.respond_to?(:include?) &amp;&amp; !selected.is_a?(String) ? selected.include?(element.last) : element.last == selected) )
      if is_selected
       options &lt;&lt; &quot;&lt;option value=\&quot;#{html_escape(element.last.to_s)}\&quot; selected=\&quot;selected\&quot;&gt;#{html_escape(element.first.to_s)}&lt;/option&gt;&quot;
     else
       options &lt;&lt; &quot;&lt;option value=\&quot;#{html_escape(element.last.to_s)}\&quot;&gt;#{html_escape(element.first.to_s)}&lt;/option&gt;&quot;
     end
   else
     is_selected = ( (selected.respond_to?(:include?) &amp;&amp; !selected.is_a?(String) ? selected.include?(element) : element == selected) )
     options &lt;&lt; ((is_selected) ? &quot;&lt;option value=\&quot;#{html_escape(element.to_s)}\&quot; selected=\&quot;selected\&quot;&gt;#{html_escape(element.to_s)}&lt;/option&gt;&quot; : &quot;&lt;option value=\&quot;#{html_escape(element.to_s)}\&quot;&gt;#{html_escape(element.to_s)}&lt;/option&gt;&quot;)
   end
  end

 options_for_select.join(&quot;\n&quot;)
end
</code></pre>

<h3>Markaby Helper</h3>

<p>We will now rewrite this code with inline markaby. We need therefore the following helper method:</p>

<pre><code>@@ruby

def markaby(&amp;proc)
  assigns = {}
  instance_variables.each do |name|
    assigns[ name[1..-1] ] =  instance_variable_get(name)
  end
  Markaby::Builder.new(assigns, self).capture(&amp;proc)
end
</code></pre>

<p>We need to collect the instance variables of the current template and
pass a hash of instance variable names along with their values to the
markaby builder. As second parameter we pass the current template, so
that the builder can access other helper methods. </p>

<h3>Usage</h3>

<p>Ok, let&#39;s rewrite the <code>options_for_select</code> helper. The method takes an
array of values which should be displayed as options. Alternatively
you may pass an list of pairs like <code>[[&#39;first&#39;,1],[&#39;second&#39;,2]</code> or an
<em>Hash</em>, which maps from option labels to their values. One thing I did
was to refactor the <code>is_selected test</code> into a lambda. It is cleaner to
separate the test and probably more efficient. Inside the loop we are
testing, if we have pairs or simple values and generate markup by
sending the option method to the builder, which causes the markaby
builder to generate an option tag. Tag attributes are defined with a
hash, which we pass to the option method. A tag method takes an
optional block, which defines the content of a tag, in our case simply
the text of the option.</p>

<pre><code>def options_for_select(container, selected = nil)
  container = container.to_a if Hash === container

  if selected.respond_to?(:include?) and !selected.is_a?(String)
    is_selected = lambda { |e| selected.include? e }
  else
    is_selected = lambda { |e| selected == e }
  end

  is_pair = lambda {|e| !e.is_a?(String) and e.respond_to?(:first) and e.respond_to?(:last) }

  markaby do
    container.each do |element|
      if is_pair[element]
        if is_selected[element.last]
          option(:value =&gt; element.last, :selected =&gt; &#39;selected&#39;) { h element.first }
        else
           option(:value =&gt; element.last) { h element.first }
        end
      else
        if is_selected[element]
          option(:value =&gt; element, :selected =&gt; &#39;selected&#39;) { h element }
        else
          option(:value =&gt; element) { h element }
        end
      end
    end
  end
end
</code></pre>

<h3>Reusable helpers</h3>

<p>Our defined markaby method is even more useful, we can accept a block
for our helper method and use it inside the markaby code:</p>

<pre><code>def tasks(&amp;block)
  markaby do
    div.tasks {
      ul {
        markaby(&amp;amp;block)
      }
    }
  end
end
</code></pre>

<p>If we have a common pattern like a list of tasks for many templates,
we can generate the common code with the tasks method and put the
actual tasks in the block:</p>

<pre><code>tasks {
  task &#39;Back to articles&#39;.t, articles_url
  task :edit, @article
  task :versions, @article
}
</code></pre>

<p>So, you can see, there is also a task helper, which is defined as follows:</p>

<pre><code>def task(text, url_or_resource, html_options={})
  if text.is_a? Symbol
    task &quot;#{text.to_s.humanize}&quot;.t, {:action =&gt; text, :id =&gt; url_or_resource}, html_options
  else
    markaby { li { link_to text, url_or_resource, html_options } }
  end
end
</code></pre>

<p>If the link text is a symbol, we are going to infer the url from the
action name which is the first parameter and the recource, which is
the second parameter in this case. Otherwise we generate a list
element and delegate the arguments to the <code>link_to helper</code>. </p>

<p>By using this simple abstraction, we have hidden the details of task
links. Instead of repeating the same pattern over and over again, we
have a common place to decide, how the tasks should look like. Markaby
makes it really easy to generate nested structures, as it takes
advantage of ruby&#39;s block syntax.</p>

                </div>
            </div>
        </div>
    </body>
</html>
