<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">

<html>
    <head>
        <title>
            Matthias Georgi
        </title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom 1.0">
        <link rel="stylesheet" media="screen" type="text/css" href="/style.css">
        <link rel="stylesheet" href="/zenburn.css">
        <script src="/highlight.pack.js">
            
        </script>
        <script>
            hljs.initHighlightingOnLoad();
        </script>
    </head>
    <body>
        <div class="container">
            <h2 id="header">
                <a href="/">
                    Matthias Georgi
                </a>
            </h2>
            <div class="content">
                <div class="article">
                    <h1>
                        <a href="/2008/12/git-store-using-git-as-versioned-data-store-in-ruby.html">
                            Git Store - using Git as versioned data store in Ruby
                        </a>
                    </h1>
                    <p>GitStore is a small Ruby library, providing an easy interface to the
version control system <a href="http://git.or.cz/">Git</a>. It aims to use Git as a versioned
data store much like the well known PStore. Basically GitStore checks
out the repository into a in-memory representation, which can be
modified and finally committed. In this way your data is stored in a
folder structure and can be checked out and examined, but the
application may access the data in a convenient hash-like way. This
library is based on <a href="http://github.com/mojombo/grit">Grit</a>, the main technology behind <a href="http://github.com/">GitHub</a>.</p>

<p><strong>
GitStore has its own <a href="/gitstore">project page</a> now!
Please look for current information there.
</strong></p>

<h3>Installation</h3>

<p>GitStore can be installed as gem easily, if you have RubyGems 1.2.0:</p>

<pre><code>$ gem sources -a http://gems.github.com (you only have to do this once)
$ sudo gem install mojombo-grit georgi-git_store
</code></pre>

<p>If you don&#39;t have RubyGems 1.2.0, you may download the package on the
<a href="http://www.newartisans.com/blog_files/git.versioned.data.store.php">github page</a> and build the gem yourself:</p>

<pre><code>$ gem build git_store.gemspec
$ sudo gem install git_store
</code></pre>

<h3>Usage Example</h3>

<p>First thing you should do, is to initialize a new git repository.</p>

<pre><code>$ mkdir test
$ cd test
$ git init
</code></pre>

<p>Now you can instantiate a GitStore instance and store some data. The
data will be serialized depending on the file extension. So for YAML
storage you can use the &#39;yml&#39; extension:</p>

<pre><code>class WikiPage &lt; Struct.new(:author, :title, :body); end
class User &lt; Struct.new(:name); end

store = GitStore.new(&#39;.&#39;)

store[&#39;users/matthias.yml&#39;] = User.new(&#39;Matthias&#39;)
store[&#39;pages/home.yml&#39;] = WikiPage.new(&#39;matthias&#39;, &#39;Home&#39;, &#39;This is the home page...&#39;)

store.commit &#39;Added user and page&#39;
</code></pre>

<p>Note that directories will be created automatically.</p>

<p>Another way to access a path is:</p>

<pre><code>store[&#39;config&#39;, &#39;wiki.yml&#39;] = { &#39;name&#39; =&gt; &#39;My Personal Wiki&#39; }
</code></pre>

<p>Finally you can access the git store as a Hash of Hashes, but in this
case you have to create the Tree objects manually:</p>

<pre><code>store[&#39;users&#39;] = GitStore::Tree.new
store[&#39;users&#39;][&#39;matthias.yml&#39;] = User.new(&#39;Matthias&#39;)
</code></pre>

<h3>Where is my data?</h3>

<p>When you call the <code>commit</code> method, your data is written back straight
into the git repository. No intermediate file representation. So if
you want to look into your data, you can use some git browser like
<a href="http://www.kernel.org/pub/software/scm/git/docs/git-gui.html">git-gui</a> or just checkout the files:</p>

<pre><code>$ git checkout
</code></pre>

<h3>Iteration</h3>

<p>Iterating over the data objects is quite easy. Furthermore you can
iterate over trees and subtrees, so you can partition your data in a
meaningful way. For example you may separate the config files and the
pages of a wiki:</p>

<pre><code>store[&#39;pages/home.yml&#39;] = WikiPage.new(&#39;matthias&#39;, &#39;Home&#39;, &#39;This is the home page...&#39;)
store[&#39;pages/about.yml&#39;] = WikiPage.new(&#39;matthias&#39;, &#39;About&#39;, &#39;About this site...&#39;)
store[&#39;pages/links.yml&#39;] = WikiPage.new(&#39;matthias&#39;, &#39;Links&#39;, &#39;Some useful links...&#39;)
store[&#39;config/wiki.yml&#39;] = { &#39;name&#39; =&gt; &#39;My Personal Wiki&#39; }

store.each { |obj| ... } # yields all pages and the config hash
store[&#39;pages&#39;].each { |page| ... } # yields only the pages
</code></pre>

<h3>Serialization</h3>

<p>Serialization is dependent on the filename extension. You can add more
handlers if you like, the interface is like this:</p>

<pre><code>class YAMLHandler
  def read(id, name, data)
    YAML.load(data)
  end

  def write(data)
    data.to_yaml
  end    
end

GitStore::Handler[&#39;yml&#39;] = YAMLHandler.new
</code></pre>

<p>Shinmun uses its own handler for files with <code>md</code> extension:</p>

<pre><code>class PostHandler
  def read(name, data)
    Post.new(:filename =&gt; name, :src =&gt; data)
  end

  def write(post)
    post.dump
  end    
end

GitStore::Handler[&#39;md&#39;] = PostHandler.new
</code></pre>

<h3>Related Work</h3>

<p>John Wiegley already has done <a href="http://www.newartisans.com/blog_files/git.versioned.data.store.php">something similar for Python</a>. His
implementation has its own git interface, GitStore uses the wonderful
<a href="http://github.com/mojombo/grit">Grit</a> library.</p>

                </div>
                <div class="article">
                    <h1>
                        <a href="/2007/5/google-like-search-results-helper.html">
                            Google-like Search Results Helper
                        </a>
                    </h1>
                    <p>Representing your search results in a user-friendly way is a common
task among web developers. Google&#39;s approach is dead simple but really
effective. The matching text is highlighted and shown with its
context. This can be implemented in less than 20 lines of code which
you can include into you helper:</p>

<pre><code>def highlight_text(text, words)
  tokens = strip_tags(text).split
  sections = []
  words.each do |word|
    word = word.downcase
    tokens.each_with_index do |token, i|
      if token.downcase.include? word
        section = tokens[i-10, 20].join(&#39; &#39;)
        words.each do |word|
          section = highlight section, word
        end
        sections &lt;&lt; section + &#39; ... &#39;
        break if sections.size &gt; 3          
      end
    end
  end
  sections.join
end
</code></pre>

<p>First we remove the html tags of the text and split the text into
tokens. Then we iterate over the search words and for each matching
token we generate a section, which contains the highlighted word. This
is done until we hav at least 4 sections, which are finally joined and
ready to be included into the search result template.</p>

                </div>
                <div class="article">
                    <h1>
                        <a href="/2007/4/rendering-markaby-in-your-helpers.html">
                            Rendering markaby in your helpers
                        </a>
                    </h1>
                    <p>Generating markup in your rails helpers is a general practice in rails
and is used throughout all rails helpers. Normally you use <code>content_tag</code>
to generate markup. But often you will encounter situations, where
nested tags force you to write ugly helper code like the following
helper method from the rails library:</p>

<pre><code>def options_for_select(container, selected = nil)
 container = container.to_a if Hash === container

 options_for_select = container.inject([]) do |options, element|
    if !element.is_a?(String) and element.respond_to?(:first) and element.respond_to?(:last)
     is_selected = ( (selected.respond_to?(:include?) &amp;&amp; !selected.is_a?(String) ? selected.include?(element.last) : element.last == selected) )
      if is_selected
       options &lt;&lt; &quot;&lt;option value=\&quot;#{html_escape(element.last.to_s)}\&quot; selected=\&quot;selected\&quot;&gt;#{html_escape(element.first.to_s)}&lt;/option&gt;&quot;
     else
       options &lt;&lt; &quot;&lt;option value=\&quot;#{html_escape(element.last.to_s)}\&quot;&gt;#{html_escape(element.first.to_s)}&lt;/option&gt;&quot;
     end
   else
     is_selected = ( (selected.respond_to?(:include?) &amp;&amp; !selected.is_a?(String) ? selected.include?(element) : element == selected) )
     options &lt;&lt; ((is_selected) ? &quot;&lt;option value=\&quot;#{html_escape(element.to_s)}\&quot; selected=\&quot;selected\&quot;&gt;#{html_escape(element.to_s)}&lt;/option&gt;&quot; : &quot;&lt;option value=\&quot;#{html_escape(element.to_s)}\&quot;&gt;#{html_escape(element.to_s)}&lt;/option&gt;&quot;)
   end
  end

 options_for_select.join(&quot;\n&quot;)
end
</code></pre>

<h3>Markaby Helper</h3>

<p>We will now rewrite this code with inline markaby. We need therefore the following helper method:</p>

<pre><code>@@ruby

def markaby(&amp;proc)
  assigns = {}
  instance_variables.each do |name|
    assigns[ name[1..-1] ] =  instance_variable_get(name)
  end
  Markaby::Builder.new(assigns, self).capture(&amp;proc)
end
</code></pre>

<p>We need to collect the instance variables of the current template and
pass a hash of instance variable names along with their values to the
markaby builder. As second parameter we pass the current template, so
that the builder can access other helper methods. </p>

<h3>Usage</h3>

<p>Ok, let&#39;s rewrite the <code>options_for_select</code> helper. The method takes an
array of values which should be displayed as options. Alternatively
you may pass an list of pairs like <code>[[&#39;first&#39;,1],[&#39;second&#39;,2]</code> or an
<em>Hash</em>, which maps from option labels to their values. One thing I did
was to refactor the <code>is_selected test</code> into a lambda. It is cleaner to
separate the test and probably more efficient. Inside the loop we are
testing, if we have pairs or simple values and generate markup by
sending the option method to the builder, which causes the markaby
builder to generate an option tag. Tag attributes are defined with a
hash, which we pass to the option method. A tag method takes an
optional block, which defines the content of a tag, in our case simply
the text of the option.</p>

<pre><code>def options_for_select(container, selected = nil)
  container = container.to_a if Hash === container

  if selected.respond_to?(:include?) and !selected.is_a?(String)
    is_selected = lambda { |e| selected.include? e }
  else
    is_selected = lambda { |e| selected == e }
  end

  is_pair = lambda {|e| !e.is_a?(String) and e.respond_to?(:first) and e.respond_to?(:last) }

  markaby do
    container.each do |element|
      if is_pair[element]
        if is_selected[element.last]
          option(:value =&gt; element.last, :selected =&gt; &#39;selected&#39;) { h element.first }
        else
           option(:value =&gt; element.last) { h element.first }
        end
      else
        if is_selected[element]
          option(:value =&gt; element, :selected =&gt; &#39;selected&#39;) { h element }
        else
          option(:value =&gt; element) { h element }
        end
      end
    end
  end
end
</code></pre>

<h3>Reusable helpers</h3>

<p>Our defined markaby method is even more useful, we can accept a block
for our helper method and use it inside the markaby code:</p>

<pre><code>def tasks(&amp;block)
  markaby do
    div.tasks {
      ul {
        markaby(&amp;amp;block)
      }
    }
  end
end
</code></pre>

<p>If we have a common pattern like a list of tasks for many templates,
we can generate the common code with the tasks method and put the
actual tasks in the block:</p>

<pre><code>tasks {
  task &#39;Back to articles&#39;.t, articles_url
  task :edit, @article
  task :versions, @article
}
</code></pre>

<p>So, you can see, there is also a task helper, which is defined as follows:</p>

<pre><code>def task(text, url_or_resource, html_options={})
  if text.is_a? Symbol
    task &quot;#{text.to_s.humanize}&quot;.t, {:action =&gt; text, :id =&gt; url_or_resource}, html_options
  else
    markaby { li { link_to text, url_or_resource, html_options } }
  end
end
</code></pre>

<p>If the link text is a symbol, we are going to infer the url from the
action name which is the first parameter and the recource, which is
the second parameter in this case. Otherwise we generate a list
element and delegate the arguments to the <code>link_to helper</code>. </p>

<p>By using this simple abstraction, we have hidden the details of task
links. Instead of repeating the same pattern over and over again, we
have a common place to decide, how the tasks should look like. Markaby
makes it really easy to generate nested structures, as it takes
advantage of ruby&#39;s block syntax.</p>

                </div>
                <a rel="next" href="page-7.html">
                    Next entries
                </a>
            </div>
        </div>
    </body>
</html>
