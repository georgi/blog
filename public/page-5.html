<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">

<html>
    <head>
        <title>
            Matthias Georgi
        </title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom 1.0">
        <link rel="stylesheet" media="screen" type="text/css" href="/style.css">
        <link rel="stylesheet" href="/zenburn.css">
        <script src="/highlight.pack.js">
            
        </script>
        <script>
            hljs.initHighlightingOnLoad();
        </script>
    </head>
    <body>
        <div class="container">
            <h2 id="header">
                <a href="/">
                    Matthias Georgi
                </a>
            </h2>
            <div class="content">
                <div class="article">
                    <h1>
                        <a href="/2008/9/emacs-completions.html">
                            Emacs Completions with Hippie-Expand and Snippets
                        </a>
                    </h1>
                    <p>One of the most important features of a text editor is the completing
of text inside a buffer. There a lots of packages for Emacs, which
provide this feature in many different ways. I will show you, what I
use to improve my life as coder.</p>

<p><EMBED SRC="/shockwaves/emacs-completion.swf" WIDTH=400 HEIGHT=320 quality=low loop=false TYPE="application/x-shockwave-flash" PLUGINSPAGE="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash"></p>

<h3>Multifunctional tab key</h3>

<p>Most of the time the tab key in Emacs is bound to the indentation
command, which will indent the current line. So if you want to use the
tab key for other things, you need some kind of multiplexer, which
tries to figure out, what is the right thing to do in each situation.</p>

<p>So I copied the indent-and-complete from the <a href="http://dima-exe.ru/rails-on-emacs" title="Emacs Rails package">emacs-rails package</a>:</p>

<pre><code>(require &#39;hippie-exp)
(require &#39;snippet)

(defun indent-and-complete ()
  &quot;Indent line and complete&quot;
  (interactive)

  (cond
   ((and (boundp &#39;snippet) snippet)
    (snippet-next-field))

   ((looking-at &quot;\\\\_&gt;&quot;)
    (hippie-expand nil))

   ((indent-for-tab-command))))
</code></pre>

<p>The function <code>indent-and-complete</code> does one of the following actions:</p>

<ul>
<li>if a snippet is active, it jumps to the next field</li>
<li>if we are at a word boundary, it tries to complete with <code>hippie-expand</code></li>
<li>otherwise it indents the current line</li>
</ul>

<h3>HTML mode initialization</h3>

<p>Well, this function alone will not change your editor behaviour. For
activating our tab function, we need to bind the tab key.</p>

<p>Additionally we want to setup <code>hippie-expand</code>, an expansion package,
which will try to expand the word before the cursor in a configurable
way. <code>hippie-expand-try-functions-list</code> is a variable, which defines a
list of functions, which should be called for completion.</p>

<p>Let&#39;s have a look at my <code>html-mode</code> initialization function. It will configure
the completion behaviour of hippie-expand an bind the tab key to <code>indent-and-complete</code>.</p>

<pre><code>;; We need a simple wrapper for expand-abbrev
(defun try-expand-abbrev (old)
  (expand-abbrev))

;; ********************************************************************************
;; HTML Mode
;;
(add-to-list &#39;auto-mode-alist &#39;(&quot;\\\\.html\\\\&#39;&quot; . html-mode))

(defun html-mode-on-init ()
  (set (make-local-variable &#39;hippie-expand-try-functions-list)
       &#39;(try-expand-abbrev
         try-expand-dabbrev))
  (define-key html-mode-map (kbd &quot;&lt;tab&gt;&quot;) &#39;indent-and-complete))

(add-hook &#39;html-mode-hook &#39;html-mode-on-init)    
</code></pre>

<p>There a two functions, which will be asked to complete the current word:</p>

<ul>
<li><p><code>try-expand-abbrev</code>: Expands the current word by looking into the
list of defined abbreviations. So called abbrevs are just shortcuts
in Emacs. So if you type <code>li</code> and hit the tab key it will be
expanded to <code>&lt;li&gt;&lt;/li&gt;</code>.</p></li>
<li><p><code>try-expand-dabbrev</code>: Dynamic abbreviation is a pragmatic method for
completing words. Emacs will look for words with the same beginning
and use them for completion. Hitting multiple times the tab key will
give you different completions, as you may know from the unix shell.</p></li>
</ul>

<h3>Defining your snippets</h3>

<p>Now if you want to use snippets for your <code>html-mode</code>, you have to
define a abbrev-table with your desired snippets. </p>

<pre><code>(define-abbrev-table &#39;html-mode-abbrev-table ())

(snippet-with-abbrev-table &#39;html-mode-abbrev-table 
 (&quot;h1&quot;      . &quot;&lt;h1&gt;$.&lt;/h1&gt;&quot;)
 (&quot;h2&quot;      . &quot;&lt;h2&gt;$.&lt;/h2&gt;&quot;)
 (&quot;h3&quot;      . &quot;&lt;h3&gt;$.&lt;/h3&gt;&quot;)
 (&quot;h4&quot;      . &quot;&lt;h3&gt;$.&lt;/h4&gt;&quot;)
 (&quot;h5&quot;      . &quot;&lt;h3&gt;$.&lt;/h5&gt;&quot;)
 (&quot;h6&quot;      . &quot;&lt;h6&gt;$.&lt;/h6&gt;&quot;)
 (&quot;div&quot;     . &quot;&lt;div&gt;$.&lt;/div&gt;&quot;)
 (&quot;divc&quot;    . &quot;&lt;div class=\&quot;$${class}\&quot;&gt;$.&lt;/div&gt;&quot;)
 (&quot;span&quot;    . &quot;&lt;span&gt;$.&lt;/span&gt;&quot;)
 (&quot;spans&quot;   . &quot;&lt;span style=\&quot;$${style}\&quot;&gt;$.&lt;/span&gt;&quot;)
 (&quot;form&quot;    . &quot;&lt;form action=\&quot;$${action}\&quot; method=\&quot;$${post}\&quot;&gt;$.&lt;/form&gt;&quot;)
 (&quot;input&quot;   . &quot;&lt;input type=\&quot;$${text}\&quot; name=\&quot;$${name}\&quot; value=\&quot;$${value}\&quot;/&gt;&quot;)
 (&quot;a&quot;       . &quot;&lt;a href=\&quot;$${href}\&quot;&gt;$.&lt;/a&gt;&quot;)
 (&quot;br&quot;      . &quot;&lt;br/&gt;$.&quot;)
 (&quot;ul&quot;      . &quot;&lt;ul&gt;$.&lt;/ul&gt;&quot;)
 (&quot;ol&quot;      . &quot;&lt;ul&gt;$.&lt;/ul&gt;&quot;)
 (&quot;li&quot;      . &quot;&lt;li&gt;$.&lt;/li&gt;&quot;)
 (&quot;tab&quot;     . &quot;&lt;table&gt;$.&lt;/table&gt;&quot;)
 (&quot;tr&quot;      . &quot;&lt;tr&gt;$.&lt;/tr&gt;&quot;)
 (&quot;td&quot;      . &quot;&lt;td&gt;$.&lt;/td&gt;&quot;)
 (&quot;th&quot;      . &quot;&lt;th&gt;$.&lt;/th&gt;&quot;)
 (&quot;str&quot;     . &quot;&lt;strong&gt;$.&lt;/strong&gt;&quot;)
 (&quot;em&quot;      . &quot;&lt;em&gt;$.&lt;/em&gt;&quot;)
 (&quot;meta&quot;    . &quot;&lt;meta name=\&quot;$${name}\&quot; content=\&quot;$${content}\&quot;/&gt;&quot;)
 (&quot;style&quot;   . &quot;&lt;style type=\&quot;text/css\&quot;&gt;$.&lt;/style&gt;&quot;)
 (&quot;script&quot;  . &quot;&lt;script type=\&quot;text/javascript\&quot;&gt;$.&lt;/script&gt;&quot;)
 (&quot;scripts&quot; . &quot;&lt;script src=\&quot;$${src}\&quot; type=\&quot;text/javascript\&quot;&gt;$.&lt;/script&gt;&quot;)
 (&quot;img&quot;     . &quot;&lt;img src=\&quot;$.\&quot;/&gt;&quot;)
 (&quot;link&quot;    . &quot;&lt;link href=\&quot;$${href}\&quot; media=\&quot;screen\&quot; rel=\&quot;stylesheet\&quot; type=\&quot;text/css\&quot;/&gt;&quot;))
</code></pre>

<p>Great. If you put all the code in your .emacs file, you should be able
to use your tab key for completions. In our case we defined snippets
for the <code>html-mode</code> and activated <code>hippie-expand</code> to use abbrevs and
dynamic abbreviation. There is much more stuff I will show you next
time, like customizations for other language modes like <em>Ruby</em> and
<em>Javascript</em>.</p>

                </div>
                <div class="article">
                    <h1>
                        <a href="/2008/9/commenting-system-with-lightweight-json-store.html">
                            Commenting system with lightweight JSON store
                        </a>
                    </h1>
                    <p>As I wrote this <a href="http://www.matthias-georgi.de/shinmun.html">blog engine</a>, the need for a commenting system
arose and I reflected about a small and simple commenting system with
just a flat file JSON store. This is my solution, which can be used on
any static page on a server with PHP support.</p>

<h3>JQuery Frontend</h3>

<p>First of all we need a form, which will post the data to the <em>PHP</em>
script. The comment rendering is done by my own <em>Javascript</em>
templating system, which I will explain in a seperate post. For now we
focus on the task of posting a form and saving it to our <em>JSON</em> store.</p>

<pre><code>&lt;div class=&quot;comment-form&quot;&gt;
    &lt;form&gt;
      &lt;input type=&quot;hidden&quot; name=&quot;guid&quot; value=&quot;7ad04f10-5dd6-012b-b53c-001a92975b89&quot;/&gt;
      &lt;p&gt;
        &lt;label&gt;Name&lt;/label&gt;&lt;br/&gt;
        &lt;input type=&quot;text&quot; name=&quot;name&quot; size=&quot;40&quot;/&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;label&gt;Website&lt;/label&gt;&lt;br/&gt;
        &lt;input type=&quot;text&quot; name=&quot;website&quot;  size=&quot;40&quot;/&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;label&gt;Comment&lt;/label&gt;&lt;br/&gt;
        &lt;textarea name=&quot;text&quot; cols=&quot;60&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Post comment&quot;/&gt;
      &lt;/p&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre>

<p>My blog engine generates a guid for each post, so this will be posted
by the form as well. Ok, let&#39;s have a look at the Javascript code:</p>

<pre><code>$(&#39;.comment-form form&#39;).ajaxForm({
    url: Blog.root + &#39;controllers/comments.php&#39;,
    type: &#39;POST&#39;,
    resetForm: true,
    beforeSubmit: function(values) {
        if (values[1].value &amp;&amp; values[3].value) {
            return true;
        }
        else {
            alert(&#39;Please enter name and text!&#39;);
            return false;
        }
    },
    success: function(data) {
        renderComments(data);
    }
});
</code></pre>

<p>This uses the <a href="http://malsup.com/jquery/form/">jquery-form plugin</a> to submit the form via <em>AJAX</em>,
nothing special here, the input will be validated to have at least a
name and comment text. After a successful comment post, the comments
should be rendered, but this is another story.</p>

<h3>PHP Backend</h3>

<p>The backend is extremely <a href="http://en.wikipedia.org/wiki/You_Ain%27t_Gonna_Need_It">YAGNI</a>. Comments for one post, will be
saved in one JSON file like <code>comments/guid-of-the-post</code>. The 4 fields
will be encoded as json array and appended to the file. This happens
only, if the request was a <em>POST</em>. Finally we read the whole file and
send it back as response.</p>

<pre><code>&lt;?php

$guid_pattern = &quot;/^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$/&quot;;
$req = $_REQUEST;
$guid = $req[&#39;guid&#39;];

preg_match($guid_pattern, $guid) or die(&quot;invalid guid&quot;);

$file = &#39;comments/&#39; . $guid;

if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;POST&#39;) {   
  // create a comment record
  $record = array(date(&#39;Y-m-d H:i:s&#39;), 
                  strip_tags(stripslashes($req[&#39;name&#39;])),
                  strip_tags(stripslashes($req[&#39;website&#39;])),
                  strip_tags(stripslashes($req[&#39;text&#39;])));

  // encode as json string
  $json = json_encode($record) . &quot;\n&quot;;

  // open the comment file for appending
  $fp = fopen($file, &quot;a&quot;);

  // acquire a write lock
  flock($fp, LOCK_EX);

  // append the json line
  fwrite($fp, $json);

  // release lock
  flock($fp, LOCK_UN);

  // close file
  fclose($fp);
}

if (file_exists($file)) {    
  // open the comment file for reading
  $fp = fopen($file, &quot;r&quot;);

  // acquire a read lock
  flock($fp, LOCK_SH);

  // read whole file and print it out
  echo fread($fp, filesize($file));

  // release lock
  flock($fp, LOCK_UN);

  // close file
  fclose($fp);
}

?&gt;
</code></pre>

<p>One important thing to note is, that the comment file is not one big
JSON array. It looks like this:</p>

<pre><code>[&quot;2008-09-07 12:28:33&quot;,&quot;Hans&quot;,&quot;&quot;,&quot;**strong text**\n*emphasized text*&quot;]
[&quot;2008-09-07 12:29:33&quot;,&quot;Hans&quot;,&quot;&quot;,&quot;**strong text**\n\n\n*emphasized text*&quot;]
[&quot;2008-09-07 12:29:56&quot;,&quot;Hans&quot;,&quot;&quot;,&quot;**strong text**\n\n\n*emphasized text*&quot;]
</code></pre>

<p>For each line, we have one JSON array. This way, the <em>PHP</em> script
doesn&#39;t need to read the whole JSON thing into memory. It just appends
on every <em>POST</em> one line.</p>

<h3>Escaping</h3>

<p>Some blog comments showed strange escaping behviour, so I investigated
further. PHP has a foolproof feature called <a href="http://de.php.net/manual/en/security.magicquotes.php">Magic Quotes</a>. It
automatically escapes all dangerous characters from request parameters
to protect dumb users from <a href="http://en.wikipedia.org/wiki/SQL_injection">SQL Injection</a>. This feature is
deprecated and in version 6.0.0 it will be removed. Nevertheless it is 
activated in a default PHP installation.</p>

<p>To revert the escaping behaviour I have to call <code>stripslashes</code>. Also I
have to care about stripping HTML tags from input. So to protect from
malicious HTML, I filter all input through <code>strip_tags</code>.</p>

<h3>Concurrency</h3>

<p>As a commenter pointed out, concurrent access can be a headache. I
hoped, that <code>file_put_contents</code> is an atomic function, but it is
not. However, I use a simple file locking scheme, which is good
enough. One caveat remains: in a multithreading environment this will
not work reliably. But I think, most PHP installations run as CGI, so
this will be ok.</p>

<h3>Security</h3>

<p>Seems that I had a serious security flaw in my first version. I didn&#39;t
check the guid parameter, so that you could pass a path like 
<code>../../../../../../etc/group</code>. Now the guid is matched against a regular
expression, so the script is now safe.</p>

<h3>Conclusion</h3>

<p>With a few lines you can hook up a simple commenting system for static
pages powered by <em>AJAX</em> and <em>PHP</em>. Note, that rendering of comments is
not discussed here and happens on <em>Javascript</em> side. </p>

<p>Read about my <a href="http://www.matthias-georgi.de/patroon.html">Javascript template engine</a> which is used to render
the comments.</p>

                </div>
                <div class="article">
                    <h1>
                        <a href="/2008/12/viewing-ri-in-a-web-browser.html">
                            Viewing RI in a web browser
                        </a>
                    </h1>
                    <p>I&#39;m a big fan of the Firefox keyword search. For example I have
keywords for <a href="http://dict.leo.org">LEO</a>, <a href="http://en.wikipedia.org">Wikipedia</a> and <a href="http://www.nongnu.org/man2html">Man pages</a>. Sometimes I
want to look up API documentation in Ruby and typing <code>ri camelize</code>
into the address bar and viewing the documentation as web page seems
to be quite natural for me. So I wrote a quick and dirty cgi, which
calls RI and outputs HTML.</p>

<h3>CGI script</h3>

<p>I&#39;ve put the following code in file named
<code>/usr/lib/cgi-bin/ri.b</code>. This is the default location for cgi scripts
on my system for Apache.</p>

<pre><code>#!/usr/bin/env ruby

require &#39;rdoc/ri/ri_driver&#39;
require &#39;rubygems&#39;

print &quot;Content-type: text/html\r\n\r\n&quot;

ARGV &lt;&lt; &#39;-f&#39; &lt;&lt; &#39;html&#39;

ri = RiDriver.new

print &#39;&lt;html&gt;&lt;body style=&quot;width:600px; margin:auto; padding:20px&quot;&gt;&#39;
ri.process_args
print &#39;&lt;/body&gt;&lt;/html&gt;&#39;
</code></pre>

<p>This script does the same thing as if you typed <code>ri somequery -f
html</code>. I put some HTML around it to give it some style, but that&#39;s it.</p>

<h3>The Keyword Search</h3>

<p>So I want to type <code>ri String.capitalize</code> and the browser should send a
request to <code>http://localhost/cgi-bin/ri.rb?String.capitalize</code>.</p>

<p>Just add a new bookmark and give it the keyword <code>ri</code> and use as url
this one:</p>

<pre><code> http://localhost/cgi-bin/ri.rb?%s
</code></pre>

<p>Now we&#39;re done. One thing I would like to improve is to add hyperlinks
to the output. For example viewing the documentation of a class brings
up all documented methods. Each of them should be a link to the actual
documentation. Probably some monkey patching on the <a href="http://rdoc.rubyforge.org/classes/RDoc/RI/HtmlFormatter.html">HtmlFormatter</a>
class would do the job.</p>

                </div>
                <a rel="next" href="page-6.html">
                    Next entries
                </a>
            </div>
        </div>
    </body>
</html>
