<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">

<html>
    <head>
        <title>
            Matthias Georgi
        </title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="alternate" type="application/atom+xml" href="http://feeds.feedburner.com/matthias-georgi" title="Atom 1.0">
        <link rel="stylesheet" media="screen" type="text/css" href="/style.css">
        <link rel="stylesheet" href="/zenburn.css">
        <script src="/highlight.pack.js">
            
        </script>
        <script>
            hljs.initHighlightingOnLoad();
        </script>
    </head>
    <body>
        <div class="container">
            <h2 id="header">
                <a href="/">
                    Matthias Georgi
                </a>
            </h2>
            <div class="content">
                <div class="article">
                    <h1>
                        <a href="/2007/4/rendering-markaby-in-your-helpers.html">
                            Rendering markaby in your helpers
                        </a>
                    </h1>
                    <p>Generating markup in your rails helpers is a general practice in rails
and is used throughout all rails helpers. Normally you use <code>content_tag</code>
to generate markup. But often you will encounter situations, where
nested tags force you to write ugly helper code like the following
helper method from the rails library:</p>

<pre><code>def options_for_select(container, selected = nil)
 container = container.to_a if Hash === container

 options_for_select = container.inject([]) do |options, element|
    if !element.is_a?(String) and element.respond_to?(:first) and element.respond_to?(:last)
     is_selected = ( (selected.respond_to?(:include?) &amp;&amp; !selected.is_a?(String) ? selected.include?(element.last) : element.last == selected) )
      if is_selected
       options &lt;&lt; &quot;&lt;option value=\&quot;#{html_escape(element.last.to_s)}\&quot; selected=\&quot;selected\&quot;&gt;#{html_escape(element.first.to_s)}&lt;/option&gt;&quot;
     else
       options &lt;&lt; &quot;&lt;option value=\&quot;#{html_escape(element.last.to_s)}\&quot;&gt;#{html_escape(element.first.to_s)}&lt;/option&gt;&quot;
     end
   else
     is_selected = ( (selected.respond_to?(:include?) &amp;&amp; !selected.is_a?(String) ? selected.include?(element) : element == selected) )
     options &lt;&lt; ((is_selected) ? &quot;&lt;option value=\&quot;#{html_escape(element.to_s)}\&quot; selected=\&quot;selected\&quot;&gt;#{html_escape(element.to_s)}&lt;/option&gt;&quot; : &quot;&lt;option value=\&quot;#{html_escape(element.to_s)}\&quot;&gt;#{html_escape(element.to_s)}&lt;/option&gt;&quot;)
   end
  end

 options_for_select.join(&quot;\n&quot;)
end
</code></pre>

<h3>Markaby Helper</h3>

<p>We will now rewrite this code with inline markaby. We need therefore the following helper method:</p>

<pre><code>@@ruby

def markaby(&amp;proc)
  assigns = {}
  instance_variables.each do |name|
    assigns[ name[1..-1] ] =  instance_variable_get(name)
  end
  Markaby::Builder.new(assigns, self).capture(&amp;proc)
end
</code></pre>

<p>We need to collect the instance variables of the current template and
pass a hash of instance variable names along with their values to the
markaby builder. As second parameter we pass the current template, so
that the builder can access other helper methods. </p>

<h3>Usage</h3>

<p>Ok, let&#39;s rewrite the <code>options_for_select</code> helper. The method takes an
array of values which should be displayed as options. Alternatively
you may pass an list of pairs like <code>[[&#39;first&#39;,1],[&#39;second&#39;,2]</code> or an
<em>Hash</em>, which maps from option labels to their values. One thing I did
was to refactor the <code>is_selected test</code> into a lambda. It is cleaner to
separate the test and probably more efficient. Inside the loop we are
testing, if we have pairs or simple values and generate markup by
sending the option method to the builder, which causes the markaby
builder to generate an option tag. Tag attributes are defined with a
hash, which we pass to the option method. A tag method takes an
optional block, which defines the content of a tag, in our case simply
the text of the option.</p>

<pre><code>def options_for_select(container, selected = nil)
  container = container.to_a if Hash === container

  if selected.respond_to?(:include?) and !selected.is_a?(String)
    is_selected = lambda { |e| selected.include? e }
  else
    is_selected = lambda { |e| selected == e }
  end

  is_pair = lambda {|e| !e.is_a?(String) and e.respond_to?(:first) and e.respond_to?(:last) }

  markaby do
    container.each do |element|
      if is_pair[element]
        if is_selected[element.last]
          option(:value =&gt; element.last, :selected =&gt; &#39;selected&#39;) { h element.first }
        else
           option(:value =&gt; element.last) { h element.first }
        end
      else
        if is_selected[element]
          option(:value =&gt; element, :selected =&gt; &#39;selected&#39;) { h element }
        else
          option(:value =&gt; element) { h element }
        end
      end
    end
  end
end
</code></pre>

<h3>Reusable helpers</h3>

<p>Our defined markaby method is even more useful, we can accept a block
for our helper method and use it inside the markaby code:</p>

<pre><code>def tasks(&amp;block)
  markaby do
    div.tasks {
      ul {
        markaby(&amp;amp;block)
      }
    }
  end
end
</code></pre>

<p>If we have a common pattern like a list of tasks for many templates,
we can generate the common code with the tasks method and put the
actual tasks in the block:</p>

<pre><code>tasks {
  task &#39;Back to articles&#39;.t, articles_url
  task :edit, @article
  task :versions, @article
}
</code></pre>

<p>So, you can see, there is also a task helper, which is defined as follows:</p>

<pre><code>def task(text, url_or_resource, html_options={})
  if text.is_a? Symbol
    task &quot;#{text.to_s.humanize}&quot;.t, {:action =&gt; text, :id =&gt; url_or_resource}, html_options
  else
    markaby { li { link_to text, url_or_resource, html_options } }
  end
end
</code></pre>

<p>If the link text is a symbol, we are going to infer the url from the
action name which is the first parameter and the recource, which is
the second parameter in this case. Otherwise we generate a list
element and delegate the arguments to the <code>link_to helper</code>. </p>

<p>By using this simple abstraction, we have hidden the details of task
links. Instead of repeating the same pattern over and over again, we
have a common place to decide, how the tasks should look like. Markaby
makes it really easy to generate nested structures, as it takes
advantage of ruby&#39;s block syntax.</p>

                </div>
                <div class="article">
                    <h1>
                        <a href="/2007/4/pretty-restful-urls-in-rails.html">
                            Pretty RESTful URLs in Rails
                        </a>
                    </h1>
                    <p>Since Release 1.2 Rails knows to generate <em>RESTful</em> routes. Each
resource is identified by an <em>URI</em>, which looks like <code>/users/123</code> . It
would be nice to have more readable URLs, which include the name of
the user: <code>/users/matthias-georgi</code>. This is a short tutorial on making
your urls pretty while retaining the REST approach.</p>

<p>Assuming that you already have an user model, we add following line to
our <code>config/routes.rb</code>:</p>

<pre><code>map.resources :users
</code></pre>

<p>You may now run the <code>scaffold_resource</code> generator in case you don&#39;t have
any <code>UsersController</code> yet. In order to remember the <em>permalink</em> for each
user, we store it in a column named <code>permalink</code> in the users
table. Before we save an user record, we have to infer a url-safe
permalink for the user name. We do this by:</p>

<pre><code>def before_save
  self.permalink = name.downcase.gsub(/[^a-z0-9]+/i, &#39;-&#39;) if permalink.blank?
end
</code></pre>

<p>Each character, which is not an <em>alphanumeric</em> will be replaced by a
dash. This is only done, if the permalink is not set already. So we
have a way for users to set their permalink manually. To avoid
duplicate permalinks, we <em>validate</em> the uniqeness of the permalink:</p>

<pre><code>validates_uniqeness_of :permalink
</code></pre>

<p>What happens now, if we browse to a user url like
<code>/users/matthias-georgi</code> ? Rails raises an exception, telling us that it
cannot find an record with the id <code>matthias-georgi</code>. We&#39;ll fix now our
controller to look for the permalink and not the id of the user. Just
replace each call to <code>User.find(params[:id])</code> with
<code>User.find_by_permalink(params[:id])</code>. Also we have to ensure, that our
user routes will be generated correctly. Therefore we overwrite the
<code>to_param</code> method:</p>

<pre><code>def to_param
  permalink
end
</code></pre>

<p>The effect of this little change is, that <code>user_url(a_user)</code> generates
the right url. <em>Nested resources</em> and <em>pretty urls</em> can get tricky and for
now I won&#39;t touch this topic. Remember that <em>changing</em> the permalink may
be problematic as links to the old url will get invalid. Nevertheless
have fun experimenting with pretty urls and the new wonderful world of
REST.</p>

                </div>
                <div class="article">
                    <h1>
                        <a href="/2007/4/fast-autocompletion-with-rails.html">
                            Fast Auto-completion with Rails, Scriptaculous and JSON
                        </a>
                    </h1>
                    <p>Inspired by the excellent <a href="http://www.pragmaticprogrammer.com/titles/fr_rr/">Rails Recipes</a> book , I created an
improved Auto-completion helper, which uses <em>JSON</em> and <em>AJAX</em> instead
of a script tag for loading the completions. What we want to achieve
is a search field, which pops up immediately, showing us a list of
possible completions for our search word. Look at <a href="http://labs.google.com/suggest/">Google Suggest</a>
to get an idea.</p>

<h3>Rails Autocomplete</h3>

<p>Rails already has an <code>auto_complete_field</code>, which sends an AJAX
request for each keystroke. This approach is quite slow, but works in
most cases, especially for large datasets <code>auto_complete_field</code> is the
better choice. Our idea, stolen from the Rails Recipes book is to
fetch the array of possible completions only once. Each keystroke will
trigger only a local lookup and need no further server interaction.</p>

<p>Scriptaculous already has the right tool for this job:
<a href="http://wiki.script.aculo.us/scriptaculous/show/Autocompleter.Local">Autocompleter.Local</a>.  We will just pass a javascript array of
possible completions to the constructor and we&#39;re done.</p>

<h3>CSS</h3>

<p>OK, let&#39;s start. First we need the CSS used by <code>Autocompleter.Local</code>,
which styles the choices box:</p>

<pre><code>@@css

div.auto_complete {
  width: 350px;
  background: #fff;
}

div.auto_complete ul {
  border:1px solid #888;
  margin:0;
  padding:0;
  width:100%;
  list-style-type:none;
}

div.auto_complete ul li {
  margin:0;
  padding:3px;
}

div.auto_complete ul li.selected {
  background-color: #ffb;
}

div.auto_complete ul strong.highlight {
  color: #800;
  margin:0;
  padding:0;
}
</code></pre>

<h3>Controller</h3>

<p>Rails already has an controller macro for generating a auto completion
action. We will create a similar macro, which will generate an action,
which in turn generates the <em>JSON</em> response. Sounds complex, but the
implementation is quite easy. Just add to your ApplicationController:</p>

<pre><code>def self.fast_auto_complete_for(object, method, options = {})
 define_method(&quot;auto_complete_for_#{object}_#{method}&quot;) do
   render :json =&gt; object.to_s.camelize.constantize.find(:all).map(&amp;method).to_json
  end
end
</code></pre>

<p>The response of the generated action will now contain a list of all
values for the desired attribute. You can use it like in your
controllers: <code>fast_auto_complete_for :sport, :name</code></p>

<h3>Javascript Helper</h3>

<p>Now let us get into the tricky part: the javascript macro helper. How
will we get the completion list? <em>Prototype</em> includes the <code>Ajax.Request</code>
class, which sends an Ajax Request to our generated action and fetches
the array encoded as <em>JSON</em>. Furthermore we have to generate a div which
will hold the popup list for our completion entries. Without going
into detail, I&#39;ll just show you the code, which you add to your
<code>ApplicationHelper</code>:</p>

<pre><code>def fast_auto_complete_field(field_id, options={})
  div_id = &quot;#{field_id}_auto_complete&quot;
  url = options.delete(:url) or raise &quot;url required&quot;
  options = options.merge(:tokens =&gt; &#39;,&#39;, :frequency =&gt; 0 )
  script = javascript_tag &lt;&lt;-end
    new Ajax.Request(&#39;#{url}&#39;, {
      method: &#39;get&#39;,
      onSuccess: function(transport) {
        new Autocompleter.Local(&#39;#{field_id}&#39;, &#39;#{div_id}&#39;, eval(transport.responseText), #{options.to_json});
      }
    });
  end
  content_tag &#39;div&#39;, script, :class =&gt; &#39;auto_complete&#39;, :id =&gt; div_id
end
</code></pre>

<p>Our helper needs the id for the text field we want to enhance. Based
on this id the helper generates the div for presenting the completion
entries. It is also required to pass the url of the json action, which
is in our case <code>/sports/auto_complete_for_sport_name</code>. </p>

<h3>Usage example</h3>

<pre><code>&lt;form&gt;
  &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;sport_name&quot;/&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Search&quot;/&gt;
&lt;/form&gt;

&lt;%= fast_auto_complete_field :sport_name, :url =&gt; &#39;/sports/auto_complete_for_sport_name&#39; %&gt;
</code></pre>

<p>Well, that&#39;s it. Now you may enjoy snappy auto-completion and feel
good about using bleeding edge technology like <code>AJAX</code> and <code>JSON</code>.</p>

                </div>
                <a rel="next" href="page-8.html">
                    Next entries
                </a>
            </div>
        </div>
    </body>
</html>
